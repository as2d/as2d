{"version":3,"sources":["src/shared/CanvasInstruction.ts","~lib/internal/allocator.ts","~lib/internal/arraybuffer.ts","src/shared/CanvasDirection.ts","src/shared/CanvasPatternRepetition.ts","src/shared/GlobalCompositeOperation.ts","src/shared/ImageSmoothingQuality.ts","src/shared/LineCap.ts","src/shared/LineJoin.ts","src/shared/TextAlign.ts","src/shared/TextBaseline.ts","src/shared/FillRule.ts","assembly/renderer/CanvasRenderingContext2D.ts","~lib/internal/string.ts","~lib/internal/typedarray.ts","~lib/memory.ts","~lib/allocator/arena.ts","~lib/internal/memory.ts","~lib/map.ts","~lib/internal/hash.ts","~lib/arraybuffer.ts","assembly/internal/getContext.ts","assembly/internal/Buffer.ts","~lib/internal/number.ts","~lib/builtins.ts","~lib/array.ts","assembly/internal/Path2DElement.ts","~lib/string.ts","assembly/renderer/Image.ts","assembly/draw-functions.test.ts","assembly/internal/util.ts","assembly/renderer/CanvasGradient.ts","assembly/renderer/CanvasPattern.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["export const enum CanvasInstruction {\r\n  Arc = 0,\r\n  ArcTo = 1,\r\n  BeginPath = 2,\r\n  BezierCurveTo = 3,\r\n  Clip = 4,\r\n  ClosePath = 5,\r\n  Commit = 6,\r\n  ClearRect = 7,\r\n  Direction = 8,\r\n  DrawFocusIfNeeded = 9,\r\n  DrawImage = 10,\r\n  Ellipse = 11,\r\n  Fill = 12,\r\n  FillGradient = 13,\r\n  FillPattern = 14,\r\n  FillRect = 15,\r\n  FillStyle = 16,\r\n  FillText = 17,\r\n  FillTextWidth = 18,\r\n  Filter = 19,\r\n  Font = 20,\r\n  GlobalAlpha = 21,\r\n  GlobalCompositeOperation = 22,\r\n  ImageSmoothingEnabled = 23,\r\n  ImageSmoothingQuality = 24,\r\n  Inspect = 25,\r\n  LineCap = 26,\r\n  LineDash = 27,\r\n  LineDashOffset = 28,\r\n  LineJoin = 29,\r\n  LineTo = 30,\r\n  LineWidth = 31,\r\n  MiterLimit = 32,\r\n  MoveTo = 33,\r\n  QuadraticCurveTo = 34,\r\n  Rect = 35,\r\n  Restore = 36,\r\n  Rotate = 37,\r\n  Save = 38,\r\n  Scale = 39,\r\n  SetTransform = 40,\r\n  ShadowBlur = 41,\r\n  ShadowColor = 42,\r\n  ShadowOffsetX = 43,\r\n  ShadowOffsetY = 44,\r\n  Stroke = 45,\r\n  StrokeGradient = 46,\r\n  StrokePattern = 47,\r\n  StrokeRect = 48,\r\n  StrokeStyle = 49,\r\n  StrokeText = 50,\r\n  StrokeTextWidth = 51,\r\n  TextAlign = 52,\r\n  TextBaseline = 53,\r\n  Translate = 54,\r\n  Transform = 55,\r\n}\r\n","/** Number of alignment bits. */\r\n@inline export const AL_BITS: u32 = 3;\r\n/** Number of possible alignment values. */\r\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\r\n/** Mask to obtain just the alignment bits. */\r\n@inline export const AL_MASK: usize = AL_SIZE - 1;\r\n/** Maximum 32-bit allocation size. */\r\n@inline export const MAX_SIZE_32: usize = 1 << 30; // 1GB\r\n","import {\r\n  AL_MASK,\r\n  MAX_SIZE_32\r\n } from \"./allocator\";\r\n\r\n/** Size of an ArrayBuffer header. */\r\n@inline export const HEADER_SIZE: usize = (offsetof<ArrayBuffer>() + AL_MASK) & ~AL_MASK;\r\n/** Maximum byte length of an ArrayBuffer. */\r\n@inline export const MAX_BLENGTH: i32 = <i32>MAX_SIZE_32 - HEADER_SIZE;\r\n\r\nfunction computeSize(byteLength: i32): usize {\r\n  // round up to power of 2, with HEADER_SIZE=8:\r\n  // 0            -> 2^3  = 8\r\n  // 1..8         -> 2^4  = 16\r\n  // 9..24        -> 2^5  = 32\r\n  // ...\r\n  // MAX_LENGTH   -> 2^30 = 0x40000000 (MAX_SIZE_32)\r\n  return <usize>1 << <usize>(<u32>32 - clz<u32>(byteLength + HEADER_SIZE - 1));\r\n}\r\n\r\n// Low-level utility\r\n\r\nfunction __gc(ref: usize): void {}\r\n\r\nexport function allocateUnsafe(byteLength: i32): ArrayBuffer {\r\n  assert(<u32>byteLength <= <u32>MAX_BLENGTH);\r\n  var buffer: usize;\r\n  if (isManaged<ArrayBuffer>()) {\r\n    buffer = __gc_allocate(computeSize(byteLength), __gc); // tslint:disable-line\r\n  } else {\r\n    buffer = memory.allocate(computeSize(byteLength));\r\n  }\r\n  store<i32>(buffer, byteLength, offsetof<ArrayBuffer>(\"byteLength\"));\r\n  return changetype<ArrayBuffer>(buffer);\r\n}\r\n\r\nexport function reallocateUnsafe(buffer: ArrayBuffer, newByteLength: i32): ArrayBuffer {\r\n  var oldByteLength = buffer.byteLength;\r\n  if (newByteLength > oldByteLength) {\r\n    assert(newByteLength <= MAX_BLENGTH);\r\n    if (newByteLength <= <i32>(computeSize(oldByteLength) - HEADER_SIZE)) { // fast path: zero out additional space\r\n      store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\r\n    } else { // slow path: copy to new buffer\r\n      let newBuffer = allocateUnsafe(newByteLength);\r\n      memory.copy(\r\n        changetype<usize>(newBuffer) + HEADER_SIZE,\r\n        changetype<usize>(buffer) + HEADER_SIZE,\r\n        <usize>oldByteLength\r\n      );\r\n      if (!isManaged<ArrayBuffer>()) {\r\n        memory.free(changetype<usize>(buffer));\r\n      }\r\n      buffer = newBuffer;\r\n    }\r\n    memory.fill(\r\n      changetype<usize>(buffer) + HEADER_SIZE + <usize>oldByteLength,\r\n      0,\r\n      <usize>(newByteLength - oldByteLength)\r\n    );\r\n  } else if (newByteLength < oldByteLength) { // fast path: override size\r\n    // TBD: worth to copy and release if size is significantly less than before?\r\n    assert(newByteLength >= 0);\r\n    store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\r\n  }\r\n  return buffer;\r\n}\r\n\r\n// The helpers below use two different types in order to emit loads and stores that load respectively\r\n// store one type to/from memory while returning/taking the desired output/input type. This allows to\r\n// emit instructions like\r\n//\r\n// * `i32.load8` ^= `<i32>load<i8>(...)` that reads an i8 but returns an i32, or\r\n// * `i64.load32_s` ^= `<i64>load<i32>(...)`) that reads a 32-bit as a 64-bit integer\r\n//\r\n// without having to emit an additional instruction for conversion purposes. The second parameter\r\n// can be omitted for references and other loads and stores that simply return the exact type.\r\n\r\n@inline export function LOAD<T,TOut = T>(buffer: ArrayBuffer, index: i32, byteOffset: i32 = 0): TOut {\r\n  return <TOut>load<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, HEADER_SIZE);\r\n}\r\n\r\n@inline export function STORE<T,TIn = T>(buffer: ArrayBuffer, index: i32, value: TIn, byteOffset: i32 = 0): void {\r\n  store<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, value, HEADER_SIZE);\r\n}\r\n","/**\r\n * The CanvasRenderingContext2D.direction value of the Canvas 2D API specifies the current text\r\n * direction used to draw text onto the canvas.\r\n */\r\nexport enum CanvasDirection {\r\n  /**\r\n   * The text direction is left-to-right.\r\n   */\r\n  ltr = 0,\r\n  /**\r\n   * The text direction is right-to-left.\r\n   */\r\n  rtl = 1,\r\n  /**\r\n   * The text direction is inherited from the <canvas> element or the Document as appropriate. Default value.\r\n   */\r\n  inherit = 2,\r\n}\r\n","/**\r\n * A value indicating how to repeat the pattern's image.\r\n */\r\nexport enum CanvasPatternRepetition {\r\n  /**\r\n   * A canvas pattern repetition indicating a repeating pattern in both the x and y directions.\r\n   */\r\n  repeat = 0,\r\n  /**\r\n   * A canvas pattern repetition indicating a repeating pattern only the x direction.\r\n   */\r\n  repeat_x = 1,\r\n  /**\r\n   * A canvas pattern repetition indicating a repeating pattern only the y direction.\r\n   */\r\n  repeat_y = 2,\r\n  /**\r\n   * A canvas pattern repetition indicationg no repeating pattern.\r\n   */\r\n  no_repeat = 3,\r\n}\r\n","/**\r\n * The GlobalCompositeOperation enum for the globalCompositeOperation property sets the type\r\n * of compositing operation to apply when drawing new shapes.\r\n */\r\nexport enum GlobalCompositeOperation {\r\n  /**\r\n   * This is the default setting and draws new shapes on top of the existing canvas content\r\n   */\r\n  source_over = 0,\r\n  /**\r\n   * The new shape is drawn only where both the new shape and the destination canvas overlap.\r\n   * Everything else is made transparent.\r\n   */\r\n  source_in = 1,\r\n  /**\r\n   * The new shape is drawn where it doesn't overlap the existing canvas content.\r\n   */\r\n  source_out = 2,\r\n  /**\r\n   * The new shape is only drawn where it overlaps the existing canvas content.\r\n   */\r\n  source_atop = 3,\r\n  /**\r\n   * New shapes are drawn behind the existing canvas content.\r\n   */\r\n  destination_over = 4,\r\n  /**\r\n   * The existing canvas content is kept where both the new shape and existing canvas content\r\n   * overlap. Everything else is made transparent.\r\n   */\r\n  destination_in = 5,\r\n  /**\r\n   * The existing content is kept where it doesn't overlap the new shape.\r\n   */\r\n  destination_out = 6,\r\n  /**\r\n   * The existing canvas is only kept where it overlaps the new shape. The new shape is drawn\r\n   * behind the canvas content.\r\n   */\r\n  destination_atop = 7,\r\n  /**\r\n   * Where both shapes overlap the color is determined by adding color values.\r\n   */\r\n  lighter = 8,\r\n  /**\r\n   * Only the new shape is shown.\r\n   */\r\n  copy = 9,\r\n  /**\r\n   * Shapes are made transparent where both overlap and drawn normal everywhere else.\r\n   */\r\n  xor = 10,\r\n  /**\r\n   * The pixels are of the top layer are multiplied with the corresponding pixel of the bottom\r\n   * layer. A darker picture is the result.\r\n   */\r\n  multiply = 11,\r\n  /**\r\n   * The pixels are inverted, multiplied, and inverted again. A lighter picture is the result\r\n   * (opposite of multiply)\r\n   */\r\n  screen = 12,\r\n  /**\r\n   * A combination of multiply and screen. Dark parts on the base layer become darker, and light\r\n   * parts become lighter.\r\n   */\r\n  overlay = 13,\r\n  /**\r\n   * Retains the darkest pixels of both layers.\r\n   */\r\n  darken = 14,\r\n  /**\r\n   * Retains the lightest pixels of both layers.\r\n   */\r\n  lighten = 15,\r\n  /**\r\n   * Divides the bottom layer by the inverted top layer.\r\n   */\r\n  color_dodge = 16,\r\n  /**\r\n   * Divides the inverted bottom layer by the top layer, and then inverts the result.\r\n   */\r\n  color_burn = 17,\r\n  /**\r\n   * A combination of multiply and screen like overlay, but with top and bottom layer swapped.\r\n   */\r\n  hard_light = 18,\r\n  /**\r\n   * A softer version of hard-light. Pure black or white does not result in pure black or white.\r\n   */\r\n  soft_light = 19,\r\n  /**\r\n   * Subtracts the bottom layer from the top layer or the other way round to always get a positive\r\n   * value.\r\n   */\r\n  difference = 20,\r\n  /**\r\n   * Like difference, but with lower contrast.\r\n   */\r\n  exclusion = 21,\r\n  /**\r\n   * Preserves the luma and chroma of the bottom layer, while adopting the hue of the top layer.\r\n   */\r\n  hue = 22,\r\n  /**\r\n   * Preserves the luma and hue of the bottom layer, while adopting the chroma of the top layer.\r\n   */\r\n  saturation = 23,\r\n  /**\r\n   * Preserves the luma of the bottom layer, while adopting the hue and chroma of the top layer.\r\n   */\r\n  color = 24,\r\n  /**\r\n   * Preserves the hue and chroma of the bottom layer, while adopting the luma of the top layer.\r\n   */\r\n  luminosity = 25,\r\n}\r\n","export enum ImageSmoothingQuality {\r\n  low = 0,\r\n  medium = 1,\r\n  high = 2,\r\n}","export enum LineCap {\r\n  butt = 0,\r\n  round = 1,\r\n  square = 2,\r\n}\r\n","/**\r\n * The LineJoin enum responsible for setting the lineJoin property of the Canvas 2D API determines\r\n * the shape used to join two line segments where they meet.\r\n *\r\n * This property has no effect wherever two connected segments have the same direction, because no\r\n * joining area will be added in this case. Degenerate segments with a length of zero (i.e., with\r\n * all endpoints and control points at the exact same position) are also ignored.\r\n */\r\nexport enum LineJoin {\r\n  /**\r\n   * Rounds off the corners of a shape by filling an additional sector of disc centered at the\r\n   * common endpoint of connected segments. The radius for these rounded corners is equal to the\r\n   * line width.\r\n   */\r\n  bevel = 0,\r\n  /**\r\n   * Fills an additional triangular area between the common endpoint of connected segments, and the\r\n   * separate outside rectangular corners of each segment.\r\n   */\r\n  round = 1,\r\n  /**\r\n   * Connected segments are joined by extending their outside edges to connect at a single point,\r\n   * with the effect of filling an additional lozenge-shaped area. This setting is affected by the\r\n   * miterLimit property. Default value.\r\n   */\r\n  miter = 2,\r\n}","/**\r\n * The TextAlign enum specifies the current text alignment used when drawing text.\r\n *\r\n * The alignment is relative to the x value of the fillText() method. For example, if textAlign is\r\n * \"center\", then the text's left edge will be at x - (textWidth / 2).\r\n */\r\nexport enum TextAlign {\r\n  /**\r\n   * The text is left-aligned.\r\n   **/\r\n  left = 0,\r\n  /**\r\n   * The text is right-aligned.\r\n   **/\r\n  right = 1,\r\n  /**\r\n   * The text is centered.\r\n   **/\r\n  center = 2,\r\n  /**\r\n   * The text is aligned at the normal start of the line (left-aligned for left-to-right locales, right-aligned for right-to-left locales).\r\n   **/\r\n  start = 3,\r\n  /**\r\n   * The text is aligned at the normal end of the line (right-aligned for left-to-right locales, left-aligned for right-to-left locales).\r\n   **/\r\n  end = 4,\r\n}\r\n","/**\r\n * The TextBasline enum specifies the current text baseline used when drawing text.\r\n */\r\nexport enum TextBaseline {\r\n  /**\r\n   * The text baseline is the top of the em square.\r\n   **/\r\n  top = 0,\r\n  /**\r\n   * The text baseline is the hanging baseline. (Used by Tibetan and other Indic scripts.)\r\n   **/\r\n  hanging = 1,\r\n  /**\r\n   * The text baseline is the middle of the em square.\r\n   **/\r\n  middle = 2,\r\n  /**\r\n   * The text baseline is the normal alphabetic baseline. Default value.\r\n   **/\r\n  alphabetic = 3,\r\n  /**\r\n   * The text baseline is the ideographic baseline; this is the bottom of the body of the characters, if the main body of characters protrudes beneath the alphabetic baseline. (Used by Chinese, Japanese, and Korean scripts.)\r\n   **/\r\n  ideographic = 4,\r\n  /**\r\n   * The text baseline is the bottom of the bounding box. This differs from the ideographic baseline in that the ideographic baseline doesn't consider descenders.\r\n   **/\r\n  bottom = 5,\r\n}","export enum FillRule {\r\n  nonzero = 0,\r\n  evenodd = 1,\r\n}\r\n","import { CanvasInstruction } from \"../../src/shared/CanvasInstruction\";\r\nimport { Buffer } from \"../internal/Buffer\";\r\nimport { LOAD, STORE } from \"internal/arraybuffer\";\r\nimport { DOMMatrix } from \"./DOMMatrix\";\r\nimport { CanvasDirection } from \"../../src/shared/CanvasDirection\";\r\nimport { CanvasPattern } from \"./CanvasPattern\";\r\nimport { CanvasGradient } from \"./CanvasGradient\";\r\nimport { Image, getImageID } from \"./Image\";\r\nimport { CanvasPatternRepetition } from \"../../src/shared/CanvasPatternRepetition\";\r\nimport { GlobalCompositeOperation } from \"../../src/shared/GlobalCompositeOperation\";\r\nimport { ImageSmoothingQuality } from \"../../src/shared/ImageSmoothingQuality\";\r\nimport { LineCap } from \"../../src/shared/LineCap\";\r\nimport { LineJoin } from \"../../src/shared/LineJoin\";\r\nimport { TextAlign } from \"../../src/shared/TextAlign\";\r\nimport { TextBaseline } from \"../../src/shared/TextBaseline\";\r\nimport { arraysEqual } from \"../internal/util\";\r\nimport { Path2DElement } from \"../internal/Path2DElement\";\r\nimport { FillRule } from \"../../src/shared/FillRule\";\r\n\r\n//#region EXTERNALS\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"render\")\r\ndeclare function render(ctxid: i32, data: usize): void;\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"createLinearGradient\")\r\ndeclare function createLinearGradient(id: i32, x0: f64, y0: f64, x1: f64, y1: f64): i32;\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"createRadialGradient\")\r\ndeclare function createRadialGradient(id: i32, x0: f64, y0: f64, r0: f64, x1: f64, y1: f64, r1: f64): i32;\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"createPattern\")\r\ndeclare function createPattern(ctxid: i32, imageid: i32, repetition: CanvasPatternRepetition): i32;\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"measureText\")\r\ndeclare function measureText(id: i32, text: string): f64;\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"isPointInPath\")\r\ndeclare function isPointInPath(id: i32, x: f64, y: f64, fillRule: FillRule): bool;\r\n\r\n// @ts-ignore: linked functions can have decorators\r\n@external(\"__canvas_sys\", \"isPointInStroke\")\r\ndeclare function isPointInStroke(id: i32, x: f64, y: f64): bool;\r\n//#endregion EXTERNALS\r\n\r\n\r\nconst enum FillStrokeStyleType {\r\n  String = 0,\r\n  CanvasPattern = 1,\r\n  CanvasGradient = 2,\r\n}\r\n\r\nvar defaultBlack: string = \"#000\";\r\nvar defaultNone: string = \"none\";\r\nvar defaultFont: string = \"10px sans-serif\";\r\nvar defaultShadowColor: string = \"rgba(0, 0, 0, 0)\";\r\nvar defaultLineDash: Float64Array = new Float64Array(0);\r\n\r\n//#region ARRAYBUFFERINITIALIZER\r\n/**\r\n * Utility function for setting the given ArrayBuffer to the identity 2d transform matrix inline.\r\n *\r\n * @param ArrayBuffer buff\r\n */\r\n// @ts-ignore: Decorators are valid here\r\nfunction setArrayBufferIdentity(buff: ArrayBuffer): ArrayBuffer {\r\n  STORE<f64>(buff, 0, 1.0);\r\n  STORE<f64>(buff, 1, 0.0);\r\n  STORE<f64>(buff, 2, 0.0);\r\n  STORE<f64>(buff, 3, 1.0);\r\n  STORE<f64>(buff, 4, 0.0);\r\n  STORE<f64>(buff, 5, 0.0);\r\n  return buff;\r\n}\r\n\r\n/**\r\n * Utility function for setting the given ArrayBuffer's first value to the specified value inline.\r\n *\r\n * @param ArrayBuffer buff\r\n * @param T value\r\n */\r\n// @ts-ignore: Decorators are valid here\r\nfunction setArrayBufferValue<T>(buff: ArrayBuffer, value: T): ArrayBuffer {\r\n  STORE<T>(buff, 0, value);\r\n  return buff;\r\n}\r\n\r\n/**\r\n * Utility function for setting the given ArrayBuffer's first value to the specified value inline.\r\n *\r\n * @param ArrayBuffer buff\r\n * @param T value\r\n */\r\n// @ts-ignore: Decorators are valid here\r\nfunction setArrayBufferValue2<T>(buff: ArrayBuffer, a: T, b: T): ArrayBuffer {\r\n  STORE<T>(buff, 0, a);\r\n  STORE<T>(buff, 1, b);\r\n  return buff;\r\n}\r\n//#endregion ARRAYBUFFERINITIALIZER\r\n\r\n/** The path element initializer. */\r\nfunction createPathElements(): Path2DElement[] {\r\n  var path: Path2DElement[] = new Array<Path2DElement>(0xFF);\r\n  for (var i = 0; i < 0x1000; i++) {\r\n    path[i] = new Path2DElement();\r\n  }\r\n  var el = unchecked(path[0]);\r\n  el.instruction = CanvasInstruction.BeginPath;\r\n  el.count = 0;\r\n  el.updateTransform = true;\r\n  return path;\r\n}\r\n\r\n/**\r\n * An AssemblyScript virtual representation of an actual CanvasRenderingContext2D Object. The\r\n * CanvasRenderingContext2D interface, part of the Canvas API, provides the 2D rendering context\r\n * for the drawing surface of a <canvas> element. It is used for drawing shapes, text, images, and\r\n * other objects.\r\n */\r\n@sealed\r\nexport class CanvasRenderingContext2D extends Buffer<CanvasInstruction> {\r\n  /**\r\n   * The component's external object id. It initializes to -1, which will never be an actual object\r\n   * id externally. If it actually returns -1, it will cause the host to error saying it cannot\r\n   * find the specified canvas context.\r\n   */\r\n  private id: i32 = -1;\r\n\r\n  /**\r\n   * The virutal stack index offset that keeps track of the number of `save()` and `restore()`\r\n   * stack states.\r\n   */\r\n  private _stackOffset: u8 = <u8>0;\r\n\r\n  //#region CREATELINEARGRADIENT\r\n  /**\r\n   * The CanvasRenderingContext2D.createLinearGradient() method of the Canvas 2D API creates a\r\n   * gradient along the line connecting two given coordinates.\r\n   *\r\n   * @param {f64} x0 - A float number representing the first x coordinate point of the gradient.\r\n   * @param {f64} y0 - A float number representing the first y coordinate point of the gradient.\r\n   * @param {f64} x1 - A float number representing the second x coordinate point of the gradient.\r\n   * @param {f64} y1 - A float number representing the second y coordinate point of the gradient.\r\n   */\r\n  public createLinearGradient(x0: f64, y0: f64, x1: f64, y1: f64): CanvasGradient {\r\n    var id: i32 = createLinearGradient(this.id, x0, y0, x1, y1);\r\n    var result: CanvasGradient = new CanvasGradient();\r\n    store<i32>(changetype<usize>(result) + offsetof<CanvasGradient>(\"id\"), id);\r\n    return result;\r\n  }\r\n  //#endregion CREATELINEARGRADIENT\r\n\r\n  //#region CREATERADIALGRADIENT\r\n  /**\r\n   * The CanvasRenderingContext2D.createRadialGradient() method of the Canvas 2D API creates a\r\n   * radial gradient using the size and coordinates of two circles.\r\n   *\r\n   * @param {f64} x0 - The x-axis coordinate of the start circle.\r\n   * @param {f64} y0 - The y-axis coordinate of the start circle.\r\n   * @param {f64} r0 - The radius of the start circle. Must be non-negative and finite.\r\n   * @param {f64} x1 - The x-axis coordinate of the end circle.\r\n   * @param {f64} y1 - The y-axis coordinate of the end circle.\r\n   * @param {f64} r1 - The radius of the end circle. Must be non-negative and finite.\r\n   */\r\n  public createRadialGradient(x0: f64, y0: f64, r0: f64, x1: f64, y1: f64, r1: f64): CanvasGradient {\r\n    var id: i32 = createRadialGradient(this.id, x0, y0, r0, x1, y1, r1);\r\n    var result: CanvasGradient = new CanvasGradient();\r\n    store<i32>(changetype<usize>(result) + offsetof<CanvasGradient>(\"id\"), id);\r\n    return result;\r\n  }\r\n  //#endregion CREATERADIALGRADIENT\r\n\r\n  //#region TRANSFORM\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of transforms. Each transform value is a set of 6 numbers\r\n   * stored in a repeated pattern of [a0, b0, c0, d0, e0, f0, a1, b1, c1, d1, e1, f1, ...].\r\n   */\r\n  private _transformStack: ArrayBuffer = setArrayBufferIdentity(new ArrayBuffer(0xFF * sizeof<f64>() * 6));\r\n\r\n  /**\r\n   * An ArrayBuffer that contains a single transform value that represents the last transform\r\n   * written by a `setTransform()` operation\r\n   */\r\n  private _currentTransform: ArrayBuffer = setArrayBufferIdentity(new ArrayBuffer(sizeof<f64>() * 6));\r\n\r\n  /**\r\n   * An operation that generates a DOMMatrix reflecting the current transform on the `_transformStack\r\n   */\r\n  @inline\r\n  private _getTransform(): DOMMatrix {\r\n    var result: DOMMatrix = new DOMMatrix();\r\n    var index: i32 = 6 * <i32>this._stackOffset;\r\n    var stack: ArrayBuffer = this._transformStack;\r\n    result.m11 = LOAD<f64>(stack, index);\r\n    result.m12 = LOAD<f64>(stack, index + 1);\r\n    result.m21 = LOAD<f64>(stack, index + 2);\r\n    result.m22 = LOAD<f64>(stack, index + 3);\r\n    result.m41 = LOAD<f64>(stack, index + 4);\r\n    result.m42 = LOAD<f64>(stack, index + 5);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * An function that sets the current transform on the `_transformStack` to the specified\r\n   * DOMMatrix values.\r\n   *\r\n   * @param {f64} a - The a property of the transform matrix.\r\n   * @param {f64} b - The b property of the transform matrix.\r\n   * @param {f64} c - The c property of the transform matrix.\r\n   * @param {f64} d - The d property of the transform matrix.\r\n   * @param {f64} e - The e property of the transform matrix.\r\n   * @param {f64} f - The f property of the transform matrix.\r\n   */\r\n  @inline\r\n  private _setTransform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    var index: i32 = 6 * <i32>this._stackOffset;\r\n    var stack: ArrayBuffer = this._transformStack;\r\n    STORE<f64>(stack, index, a);\r\n    STORE<f64>(stack, index + 1, b);\r\n    STORE<f64>(stack, index + 2, c);\r\n    STORE<f64>(stack, index + 3, d);\r\n    STORE<f64>(stack, index + 4, e);\r\n    STORE<f64>(stack, index + 5, f);\r\n  }\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.currentTransform property of the Canvas 2D API returns or sets a\r\n   * DOMMatrix (current specification) object for the current transformation matrix\r\n  */\r\n  public get currentTransform(): DOMMatrix {\r\n    return this._getTransform();\r\n  }\r\n\r\n  public set currentTransform(value: DOMMatrix) {\r\n    this._setTransform(value.m11, value.m12, value.m21, value.m22, value.m41, value.m42);\r\n  }\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.getTransform() method of the Canvas 2D API gets the current\r\n   * transformation matrix, and returns a DOMMatrix\r\n   */\r\n  public getTransform(): DOMMatrix {\r\n    return this._getTransform();\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current transform value on the _transformStack to the\r\n   * buffer if it currently does not match the last written transform.\r\n   */\r\n  private _updateTransform(): void {\r\n    var index: i32 = this._stackOffset * 6;\r\n    var stack: ArrayBuffer = this._transformStack;\r\n    var a = LOAD<f64>(stack, index);\r\n    var b = LOAD<f64>(stack, index + 1);\r\n    var c = LOAD<f64>(stack, index + 2);\r\n    var d = LOAD<f64>(stack, index + 3);\r\n    var e = LOAD<f64>(stack, index + 4);\r\n    var f = LOAD<f64>(stack, index + 5);\r\n\r\n    var current: ArrayBuffer = this._currentTransform;\r\n    if ( a != LOAD<f64>(current, 0)\r\n      || b != LOAD<f64>(current, 1)\r\n      || c != LOAD<f64>(current, 2)\r\n      || d != LOAD<f64>(current, 3)\r\n      || e != LOAD<f64>(current, 4)\r\n      || f != LOAD<f64>(current, 5)) {\r\n      super._writeSix(CanvasInstruction.SetTransform, a, b, c, d, e, f);\r\n      STORE<f64>(current, 0, a);\r\n      STORE<f64>(current, 1, b);\r\n      STORE<f64>(current, 2, c);\r\n      STORE<f64>(current, 3, d);\r\n      STORE<f64>(current, 4, e);\r\n      STORE<f64>(current, 5, f);\r\n    }\r\n  }\r\n  //#endregion TRANSFORM\r\n\r\n  //#region DIRECTION\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of CanvasDirection values, stored as `i32` values\r\n   */\r\n  private _directionStack: ArrayBuffer\r\n    = setArrayBufferValue<CanvasDirection>(new ArrayBuffer(0xFF * 4), CanvasDirection.inherit);\r\n\r\n  /**\r\n   * A private member that contains a single CanvasDirection value that represents the last\r\n   * CanvasDirection value written by a drawing operation\r\n   */\r\n  private _currentDirection: CanvasDirection = CanvasDirection.inherit;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.direction property of the Canvas 2D API specifies the current text\r\n   * direction used to draw text\r\n   */\r\n  public get direction(): CanvasDirection {\r\n    return LOAD<CanvasDirection>(this._directionStack, <i32>this._stackOffset);\r\n  }\r\n\r\n  public set direction(value: CanvasDirection) {\r\n    STORE<CanvasDirection>(this._directionStack, <i32>this._stackOffset, value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current CanvasDirection value on the _directionStack to\r\n   * the buffer if it currently does not match the last written CanvasDirection.\r\n   */\r\n  @inline\r\n  private _updateDirection(): void {\r\n    var value: CanvasDirection = LOAD<CanvasDirection>(this._directionStack, <i32>this._stackOffset);\r\n    if (value != this._currentDirection) {\r\n      this._currentDirection = value;\r\n      super._writeOne(CanvasInstruction.Direction, <f64>value);\r\n    }\r\n  }\r\n  //#endregion DIRECTION\r\n\r\n  //#region FILLSTYLE\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of 2 i32 values. For each fillStyle, if the fillStyle is\r\n   * a string, the second i32 value will be a pointer, otherwise, it's a `usize` representing the\r\n   * style's external objectID.\r\n   */\r\n  private _fillStyleStack: ArrayBuffer = setArrayBufferValue2<usize>(\r\n    new ArrayBuffer(0xFF * sizeof<usize>() * 2),\r\n    <usize>FillStrokeStyleType.String,\r\n    changetype<usize>(defaultBlack),\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single StrokeFillStyleType value that represents the last\r\n   * fillStyle value written by a drawing operation\r\n   */\r\n  private _currentFillStyleType: FillStrokeStyleType = FillStrokeStyleType.String;\r\n\r\n  /**\r\n   * A private member that contains a single pointer or id value that represents the last\r\n   * fillStyle value written by a drawing operation\r\n   */\r\n  private _currentFillStyleValue: usize = changetype<usize>(defaultBlack);\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.fillStyle property of the Canvas 2D API specifies the current text\r\n   * representing a CSS Color\r\n   */\r\n  public get fillStyle(): string | null {\r\n    var index: i32 = this._stackOffset * 2;\r\n    var fillStyleType: FillStrokeStyleType = <FillStrokeStyleType>LOAD<usize>(\r\n      this._fillStyleStack,\r\n      index,\r\n    );\r\n    if (fillStyleType == FillStrokeStyleType.String) {\r\n      return changetype<string>(LOAD<usize>(this._fillStyleStack, index + 1));\r\n    }\r\n    return null;\r\n  }\r\n\r\n  public set fillStyle(value: string | null) {\r\n    if (value == null) value = defaultBlack;\r\n    var index: i32 = this._stackOffset * 2;\r\n    var buff: ArrayBuffer = this._fillStyleStack;\r\n    STORE<usize>(buff, index, <usize>FillStrokeStyleType.String);\r\n    STORE<usize>(buff, index + 1, changetype<usize>(value));\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current fillStyle value on the _fillStyleStack to the\r\n   * buffer if it currently does not match the last written fillStyle.\r\n   */\r\n  @inline\r\n  private _updateFillStyle(): void {\r\n    var buff: ArrayBuffer = this._fillStyleStack;\r\n    var index: i32 = <i32>this._stackOffset * 2;\r\n    var styleType: FillStrokeStyleType = <FillStrokeStyleType>LOAD<usize>(buff, index);\r\n    var value: usize = LOAD<usize>(buff, index + 1);\r\n    if (styleType != this._currentFillStyleType || value != this._currentFillStyleValue) {\r\n      var inst: CanvasInstruction;\r\n      if (styleType == FillStrokeStyleType.String) inst = CanvasInstruction.FillStyle;\r\n      else if (styleType == FillStrokeStyleType.CanvasGradient) inst = CanvasInstruction.FillGradient;\r\n      else inst = CanvasInstruction.FillPattern;\r\n      super._writeOne(inst, <f64>value);\r\n    }\r\n  }\r\n  //#endregion FILLSTYLE\r\n\r\n  //#region FILLPATTERN\r\n  /**\r\n   * The CanvasRenderingContext2D.fillPattern property of the Canvas 2D API specifies the current\r\n   * fillStyle pattern\r\n   */\r\n  public get fillPattern(): CanvasPattern | null {\r\n    var index: i32 = this._stackOffset * 2;\r\n    var buff: ArrayBuffer = this._fillStyleStack;\r\n    var fillStyleType: FillStrokeStyleType = <FillStrokeStyleType>LOAD<i32>(\r\n      buff,\r\n      index,\r\n    );\r\n\r\n    if (fillStyleType == FillStrokeStyleType.CanvasPattern) {\r\n      var result: CanvasPattern = new CanvasPattern();\r\n      store<i32>(\r\n        changetype<usize>(result) + offsetof<CanvasPattern>(\"id\"),\r\n        LOAD<i32>(buff, index + 1),\r\n      );\r\n      return result;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  public set fillPattern(value: CanvasPattern | null) {\r\n    if (value == null) {\r\n      this.fillStyle = defaultBlack;\r\n      return;\r\n    }\r\n    var index: i32 = this._stackOffset * 2;\r\n    var buff: ArrayBuffer = this._fillStyleStack;\r\n    STORE<i32>(buff, index, FillStrokeStyleType.CanvasPattern);\r\n    STORE<i32>(buff, index + 1, load<i32>(changetype<usize>(value) + offsetof<CanvasPattern>(\"id\")));\r\n  }\r\n  //#endregion FILLPATTERN\r\n\r\n  //#region FILLGRADIENT\r\n  /**\r\n   * The CanvasRenderingContext2D.fillGradient property of the Canvas 2D API specifies the current\r\n   * fillStyle gradient\r\n   */\r\n  public get fillGradient(): CanvasGradient | null {\r\n    var index: i32 = this._stackOffset * 2;\r\n    var buff: ArrayBuffer = this._fillStyleStack;\r\n    var fillStyleType: FillStrokeStyleType = <FillStrokeStyleType>LOAD<i32>(\r\n      buff,\r\n      index,\r\n    );\r\n    if (fillStyleType == FillStrokeStyleType.CanvasGradient) {\r\n      var result: CanvasGradient = new CanvasGradient();\r\n      store<i32>(\r\n        changetype<usize>(result) + offsetof<CanvasGradient>(\"id\"),\r\n        LOAD<i32>(buff, index + 1),\r\n      );\r\n      return result;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  public set fillGradient(value: CanvasGradient | null) {\r\n    if (value == null) {\r\n      this.fillStyle = defaultBlack;\r\n      return;\r\n    }\r\n    var index: i32 = this._stackOffset * 2;\r\n    var buff: ArrayBuffer = this._fillStyleStack;\r\n    STORE<i32>(buff, index, FillStrokeStyleType.CanvasGradient);\r\n    STORE<i32>(buff, index + 1, load<i32>(changetype<usize>(value) + offsetof<CanvasGradient>(\"id\")));\r\n  }\r\n  //#endregion FILLGRADIENT\r\n\r\n  //#region CREATEPATTERN\r\n  /**\r\n   * The CanvasRenderingContext2D.createPattern() method of the Canvas 2D API creates a pattern\r\n   * using the specified image and repetition.\r\n   *\r\n   * @param {Image} img - A CanvasImageSource to be used as the pattern's Image.\r\n   * @param {CanvasPatternRepetition} repetition - An enum value indicating how to repeat the pattern's image.\r\n   */\r\n  public createPattern(img: Image, repetition: CanvasPatternRepetition): CanvasPattern {\r\n    var result = new CanvasPattern();\r\n    var id: i32 = load<i32>(changetype<usize>(img) + offsetof<Image>(\"_id\"));\r\n    store<i32>(changetype<usize>(result) + offsetof<CanvasPattern>(\"id\"), createPattern(this.id, id, repetition));\r\n    return result;\r\n  }\r\n  //#endregion CREATEPATTERN\r\n\r\n  //#region FILTER\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of string pointer values.\r\n   */\r\n  private _filterStack: ArrayBuffer = setArrayBufferValue(\r\n    new ArrayBuffer(0xFF * sizeof<usize>()),\r\n    changetype<usize>(defaultNone),\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single string value that represents the last\r\n   * filter value written by a drawing operation.\r\n   */\r\n  private _currentFilter: string = defaultNone;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.filter property of the Canvas 2D API provides filter effects such\r\n   * as blurring and grayscaling. It is similar to the CSS filter property and accepts the same\r\n   * values.\r\n   */\r\n  public get filter(): string {\r\n    return changetype<string>(LOAD<usize>(this._filterStack, <i32>this._stackOffset));\r\n  }\r\n\r\n  public set filter(value: string) {\r\n    STORE<usize>(this._filterStack, <i32>this._stackOffset, changetype<usize>(value));\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current filter value on the _filterStack if it currently\r\n   * does not match the last written filter string value to the buffer using write_one.\r\n   */\r\n  @inline\r\n  private _updateFilter(): void {\r\n    var value: string = changetype<string>(LOAD<usize>(this._filterStack, <i32>this._stackOffset));\r\n    if (value != this._currentFilter) {\r\n      this._currentFilter = value;\r\n      super._writeOne(CanvasInstruction.Filter, changetype<usize>(value));\r\n    }\r\n  }\r\n  //#endregion FILTER\r\n\r\n  //#region FONT\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of string pointer values.\r\n   */\r\n  private _fontStack: ArrayBuffer = setArrayBufferValue(\r\n    new ArrayBuffer(0xFF * sizeof<usize>()),\r\n    changetype<usize>(defaultFont),\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single string value that represents the last\r\n   * font value written by a drawing operation.\r\n   */\r\n  private _currentFont: string = defaultFont;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.font property of the Canvas 2D API specifies the current text\r\n   * style to use when drawing text. This string uses the same syntax as the CSS font specifier.\r\n   */\r\n  public get font(): string {\r\n    return changetype<string>(LOAD<usize>(this._fontStack, <i32>this._stackOffset));\r\n  }\r\n\r\n  public set font(value: string) {\r\n    STORE<usize>(this._fontStack, <i32>this._stackOffset, changetype<usize>(value));\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current font value on the _fontStack to the buffer if it\r\n   * currently does not match the last written font string value.\r\n   */\r\n  @inline\r\n  private _updateFont(): void {\r\n    var value: string = changetype<string>(LOAD<usize>(this._fontStack, <i32>this._stackOffset));\r\n    if (value != this._currentFont) {\r\n      this._currentFont = value;\r\n      super._writeOne(CanvasInstruction.Font, changetype<usize>(value));\r\n    }\r\n  }\r\n  //#endregion FONT\r\n\r\n  //#region GLOBALALPHA\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of f64 values.\r\n   */\r\n  private _globalAlphaStack: ArrayBuffer = setArrayBufferValue(\r\n    new ArrayBuffer(0xFF * sizeof<f64>()),\r\n    1.0,\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single float value that represents the last globalAlpha value\r\n   * written by a drawing operation.\r\n   */\r\n  private _currentGlobalAlpha: f64 = 1.0;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.globalAlpha property of the Canvas 2D API specifies the alpha\r\n   * (transparency) value that is applied to shapes and images before they are drawn onto the\r\n   * canvas.\r\n   */\r\n  public get globalAlpha(): f64 {\r\n    return LOAD<f64>(this._globalAlphaStack, <i32>this._stackOffset);\r\n  }\r\n\r\n  public set globalAlpha(value: f64) {\r\n    if (!isFinite(value) || value < 0.0 || value > 1.0) return;\r\n    STORE<f64>(this._globalAlphaStack, <i32>this._stackOffset, value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current globalAlpha value on the _globalAlphaStack to the\r\n   * buffer if it currently does not match the last written globalAlpha value.\r\n   */\r\n  @inline\r\n  private _updateGlobalAlpha(): void {\r\n    var value: f64 = LOAD<f64>(this._globalAlphaStack, <i32>this._stackOffset);\r\n    if (value != this._currentGlobalAlpha) {\r\n      this._currentGlobalAlpha = value;\r\n      super._writeOne(CanvasInstruction.GlobalAlpha, value);\r\n    }\r\n  }\r\n  //#endregion GLOBALALPHA\r\n\r\n  //#region GLOBALCOMPOSITEOPERATION\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of GlobalCompositeOperation values.\r\n   */\r\n  private _globalCompositeOperationStack: ArrayBuffer = setArrayBufferValue<GlobalCompositeOperation>(\r\n    new ArrayBuffer(0xFF * sizeof<GlobalCompositeOperation>()),\r\n    GlobalCompositeOperation.source_over,\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single GlobalCompositeOperation value that represents the last\r\n   * globalCompositeOperation value written by a drawing operation.\r\n   */\r\n  private _currentGlobalCompositeOperation: GlobalCompositeOperation = GlobalCompositeOperation.source_over;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.globalCompositeOperation property of the Canvas 2D API sets the\r\n   * type of compositing operation to apply when drawing new shapes.\r\n   */\r\n  public get globalCompositeOperation(): GlobalCompositeOperation {\r\n    return LOAD<GlobalCompositeOperation>(this._globalCompositeOperationStack, <i32>this._stackOffset);\r\n  }\r\n\r\n  public set globalCompositeOperation(value: GlobalCompositeOperation) {\r\n    STORE<GlobalCompositeOperation>(this._globalCompositeOperationStack, <i32>this._stackOffset, value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current globalCompositeOperation value on the\r\n   * _globalCompositeOperationStack to the buffer if it currently does not match the last written\r\n   * globalCompositeOperation value.\r\n   */\r\n  @inline\r\n  private _updateGlobalCompositeOperation(): void {\r\n    var value: GlobalCompositeOperation = LOAD<GlobalCompositeOperation>(\r\n      this._globalCompositeOperationStack,\r\n      <i32>this._stackOffset,\r\n    );\r\n    if (value != this._currentGlobalCompositeOperation) {\r\n      this._currentGlobalCompositeOperation = value;\r\n      super._writeOne(CanvasInstruction.GlobalCompositeOperation, <f64>value);\r\n    }\r\n  }\r\n  //#endregion GLOBALCOMPOSITEOPERATION\r\n\r\n  //#region IMAGESMOOTHINGENABLED\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of bool values.\r\n   */\r\n  private _imageSmoothingEnabledStack: ArrayBuffer = setArrayBufferValue<bool>(\r\n    new ArrayBuffer(0xFF * sizeof<bool>()),\r\n    true,\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single bool value that represents the last\r\n   * imageSmoothingEnabled value written by a drawing operation.\r\n   */\r\n  private _currentImageSmoothingEnabled: bool = true;\r\n\r\n  /**\r\n   * The imageSmoothingEnabled property of the CanvasRenderingContext2D interface, part of the\r\n   * Canvas API, determines whether scaled images are smoothed (true, default) or not (false). On\r\n   * getting the imageSmoothingEnabled property, the last value it was set to is returned.\r\n   */\r\n  public get imageSmoothingEnabled(): bool {\r\n    return LOAD<bool>(this._imageSmoothingEnabledStack, <i32>this._stackOffset);\r\n  }\r\n\r\n  public set imageSmoothingEnabled(value: bool) {\r\n    STORE<bool>(this._imageSmoothingEnabledStack, <i32>this._stackOffset, value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current imageSmoothingEnabled value on the\r\n   * _imageSmoothingEnabledStack to the buffer if it currently does not match the last written\r\n   * imageSmoothingEnabled value.\r\n   */\r\n  @inline\r\n  private _updateImageSmoothingEnabled(): void {\r\n    var value: bool = LOAD<bool>(this._imageSmoothingEnabledStack, <i32>this._stackOffset);\r\n    if (value != this._currentImageSmoothingEnabled) {\r\n      this._currentImageSmoothingEnabled = value;\r\n      super._writeOne(CanvasInstruction.ImageSmoothingEnabled, value ? 1.0 : 0.0);\r\n    }\r\n  }\r\n  //#endregion IMAGESMOOTHINGENABLED\r\n\r\n  //#region IMAGESMOOTHINGQUALITY\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of ImageSmoothingQuality values.\r\n   */\r\n  private _imageSmoothingQualityStack: ArrayBuffer = setArrayBufferValue<ImageSmoothingQuality>(\r\n    new ArrayBuffer(0xFF * sizeof<ImageSmoothingQuality>()),\r\n    ImageSmoothingQuality.low,\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single ImageSmoothingQuality value that represents the last\r\n   * imageSmoothingQuality value written by a drawing operation.\r\n   */\r\n  private _currentImageSmoothingQuality: ImageSmoothingQuality = ImageSmoothingQuality.low;\r\n\r\n  /**\r\n   * The imageSmoothingQuality property of the CanvasRenderingContext2D interface, part of the\r\n   * Canvas API, lets you set the quality of image smoothing.\r\n   */\r\n  public get imageSmoothingQuality(): ImageSmoothingQuality {\r\n    return LOAD<ImageSmoothingQuality>(this._imageSmoothingQualityStack, <i32>this._stackOffset);\r\n  }\r\n\r\n  public set imageSmoothingQuality(value: ImageSmoothingQuality) {\r\n    STORE<ImageSmoothingQuality>(this._imageSmoothingQualityStack, <i32>this._stackOffset, value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current imageSmoothingQuality value on the\r\n   * _imageSmoothingQualityStack to the buffer if it currently does not match the last written\r\n   * imageSmoothingQuality value, and imageSmoothingEnabled is true.\r\n   */\r\n  @inline\r\n  private _updateImageSmoothingQuality(): void {\r\n    if (LOAD<bool>(this._imageSmoothingEnabledStack, <i32>this._stackOffset)) {\r\n      var value: ImageSmoothingQuality = LOAD<ImageSmoothingQuality>(\r\n        this._imageSmoothingQualityStack,\r\n        <i32>this._stackOffset,\r\n      );\r\n      if (value != this._currentImageSmoothingQuality) {\r\n        this._currentImageSmoothingQuality = value;\r\n        super._writeOne(CanvasInstruction.ImageSmoothingQuality, <f64>value);\r\n      }\r\n    }\r\n  }\r\n  //#endregion IMAGESMOOTHINGQUALITY\r\n\r\n  //#region LINECAP\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of LineCap values.\r\n   */\r\n  private _lineCapStack: ArrayBuffer = setArrayBufferValue<LineCap>(\r\n    new ArrayBuffer(0xFF * sizeof<LineCap>()),\r\n    LineCap.butt,\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single LineCap value that represents the last\r\n   * lineCap value written by a drawing operation.\r\n   */\r\n  private _currentLineCap: LineCap = LineCap.butt;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.lineCap property of the Canvas 2D API determines the shape used\r\n   * to draw the end points of lines.\r\n   */\r\n  public get lineCap(): LineCap {\r\n    return LOAD<LineCap>(this._lineCapStack, <i32>this._stackOffset);\r\n  }\r\n\r\n  public set lineCap(value: LineCap) {\r\n    STORE<LineCap>(this._lineCapStack, <i32>this._stackOffset, value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current lineCap value on the _lineCapStack to the buffer\r\n   * if it currently does not match the last written lineCap value.\r\n   */\r\n  @inline\r\n  private _updateLineCap(): void {\r\n    var value: LineCap = LOAD<LineCap>(\r\n      this._lineCapStack,\r\n      <i32>this._stackOffset,\r\n    );\r\n    if (value != this._currentLineCap) {\r\n      this._currentLineCap = value;\r\n      super._writeOne(CanvasInstruction.LineCap, <f64>value);\r\n    }\r\n  }\r\n  //#endregion LINECAP\r\n\r\n  //#region LINEDASH\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of usize pointer values.\r\n   */\r\n  private _lineDashStack: ArrayBuffer = setArrayBufferValue<usize>(\r\n    new ArrayBuffer(0xFF * sizeof<usize>()),\r\n    changetype<usize>(defaultLineDash),\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single LineCap value that represents the last\r\n   * lineCap value written by a drawing operation.\r\n   */\r\n  private _currentLineDash: Float64Array = defaultLineDash;\r\n\r\n  /**\r\n   * The getLineDash() method of the Canvas 2D API's CanvasRenderingContext2D interface gets the\r\n   * current line dash pattern.\r\n   */\r\n  public getLineDash(): Float64Array {\r\n    return this._getLineDash();\r\n  }\r\n\r\n  /**\r\n   * The setLineDash() method of the Canvas 2D API's CanvasRenderingContext2D interface sets the\r\n   * line dash pattern used when stroking lines. It uses a Float64Array of values that specify\r\n   * alternating lengths of lines and gaps which describe the pattern.\r\n   *\r\n   * @param {Float64Array} value - An Array of numbers that specify distances to alternately draw a\r\n   * line and a gap (in coordinate space units). If the number of elements in the array is odd, the\r\n   * elements of the array get copied and concatenated. For example, Float64Array [5, 15, 25] will\r\n   * become Float64Array [5, 15, 25, 5, 15, 25]. If the array is empty, the line dash list is\r\n   * cleared and line strokes return to being solid.\r\n   */\r\n  public setLineDash(value: Float64Array): void {\r\n    STORE<usize>(this._lineDashStack, <i32>this._stackOffset, changetype<usize>(value));\r\n  }\r\n\r\n  /**\r\n   * An internal getLineDash function that loops backwards from the current stackOffset until it\r\n   * doesn't find a null pointer, then returns the reference.\r\n   */\r\n  @inline\r\n  private _getLineDash(): Float64Array {\r\n    var offset: i32 = this._stackOffset;\r\n    var pointer: usize = LOAD<usize>(this._lineDashStack, offset);\r\n    while (changetype<Float64Array>(pointer) == null) {\r\n      --offset;\r\n      pointer = LOAD<usize>(this._lineDashStack, offset);\r\n    }\r\n    return changetype<Float64Array>(pointer);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current lineDash value on the _lineDashStack to the buffer\r\n   * if it currently does not match the last written lineCap value.\r\n   */\r\n  @inline\r\n  private _updateLineDash(): void {\r\n    var lineDash: Float64Array = this._getLineDash();\r\n    var current: Float64Array = this._currentLineDash;\r\n\r\n    if (!arraysEqual(current, lineDash)) {\r\n      this._currentLineDash = lineDash;\r\n      super._writeOne(CanvasInstruction.LineDash, <f64>changetype<usize>(lineDash));\r\n    }\r\n  }\r\n  //#endregion LINEDASH\r\n\r\n  //#region LINEDASHOFFSET\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of f64 values.\r\n   */\r\n  private _lineDashOffsetStack: ArrayBuffer = setArrayBufferValue(\r\n    new ArrayBuffer(0xFF * sizeof<f64>()),\r\n    0.0,\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single float value that represents the last lineDashOffset value\r\n   * written by a drawing operation.\r\n   */\r\n  private _currentLineDashOffset: f64 = 0.0;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.lineDashOffset property of the Canvas 2D API sets the line dash\r\n   * offset, or \"phase.\"\r\n   */\r\n  public get lineDashOffset(): f64 {\r\n    return LOAD<f64>(this._lineDashOffsetStack, <i32>this._stackOffset);\r\n  }\r\n\r\n  public set lineDashOffset(value: f64) {\r\n    if (!isFinite(value)) return;\r\n    STORE<f64>(this._lineDashOffsetStack, <i32>this._stackOffset, value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current lineDashOffset value on the _lineDashOffsetStack\r\n   * to the buffer if it currently does not match the last written lineDashOffset value.\r\n   */\r\n  @inline\r\n  private _updateLineDashOffset(): void {\r\n    var value: f64 = LOAD<f64>(this._lineDashOffsetStack, <i32>this._stackOffset);\r\n    if (value != this._currentLineDashOffset) {\r\n      this._currentLineDashOffset = value;\r\n      super._writeOne(CanvasInstruction.LineDashOffset, value);\r\n    }\r\n  }\r\n  //#endregion LINEDASHOFFSET\r\n\r\n  //#region LINEJOIN\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of LineJoin values.\r\n   */\r\n  private _lineJoinStack: ArrayBuffer = setArrayBufferValue<LineJoin>(\r\n    new ArrayBuffer(0xFF * sizeof<LineJoin>()),\r\n    LineJoin.miter,\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single LineJoin value that represents the last\r\n   * lineJoin value written by a drawing operation.\r\n   */\r\n  private _currentLineJoin: LineJoin = LineJoin.miter;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.lineJoin property of the Canvas 2D API determines the shape used\r\n   * to join two line segments where they meet.\r\n   *\r\n   * This property has no effect wherever two connected segments have the same direction, because\r\n   * no joining area will be added in this case. Degenerate segments with a length of zero (i.e.,\r\n   * with all endpoints and control points at the exact same position) are also ignored.\r\n   */\r\n  public get lineJoin(): LineJoin {\r\n    return LOAD<LineJoin>(this._lineJoinStack, <i32>this._stackOffset);\r\n  }\r\n\r\n  public set lineJoin(value: LineJoin) {\r\n    STORE<LineJoin>(this._lineJoinStack, <i32>this._stackOffset, value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current lineJoin value on the  _lineJoinStack if it\r\n   * currently does not match the last written lineJoin value.\r\n   */\r\n  @inline\r\n  private _updateLineJoin(): void {\r\n    var value: LineJoin = LOAD<LineJoin>(\r\n      this._lineJoinStack,\r\n      <i32>this._stackOffset,\r\n    );\r\n    if (value != this._currentLineJoin) {\r\n      this._currentLineJoin = value;\r\n      super._writeOne(CanvasInstruction.LineJoin, <f64>value);\r\n    }\r\n  }\r\n  //#endregion\r\n\r\n  //#region LINEWIDTH\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of f64 values.\r\n   */\r\n  private _lineWidthStack: ArrayBuffer = setArrayBufferValue(\r\n    new ArrayBuffer(0xFF * sizeof<f64>()),\r\n    1.0,\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single float value that represents the last lineWidth value\r\n   * written by a drawing operation.\r\n   */\r\n  private _currentLineWidth: f64 = 1.0;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.lineWidth property of the Canvas 2D API sets the line dash\r\n   * offset, or \"phase.\"\r\n   */\r\n  public get lineWidth(): f64 {\r\n    return LOAD<f64>(this._lineWidthStack, <i32>this._stackOffset);\r\n  }\r\n\r\n  public set lineWidth(value: f64) {\r\n    if (!isFinite(value) || value < 0) return;\r\n    STORE<f64>(this._lineWidthStack, <i32>this._stackOffset, value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current lineWidth value on the _lineWidthStack to the\r\n   * buffer if it currently does not match the last written lineWidth value.\r\n   */\r\n  @inline\r\n  private _updateLineWidth(): void {\r\n    var value: f64 = LOAD<f64>(this._lineWidthStack, <i32>this._stackOffset);\r\n    if (value != this._currentLineWidth) {\r\n      this._currentLineWidth = value;\r\n      super._writeOne(CanvasInstruction.LineWidth, value);\r\n    }\r\n  }\r\n  //#endregion\r\n\r\n  //#region MITERLIMIT\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of f64 values.\r\n   */\r\n  private _miterLimitStack: ArrayBuffer = setArrayBufferValue(\r\n    new ArrayBuffer(0xFF * sizeof<f64>()),\r\n    10.0,\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single float value that represents the last miterLimit value\r\n   * written by a drawing operation.\r\n   */\r\n  private _currentMiterLimit: f64 = 10.0;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.miterLimit property of the Canvas 2D API sets the miter limit\r\n   * ratio. It establishes a limit on the miter when two lines join at a sharp angle, to let you\r\n   * control how thick the junction becomes.\r\n   */\r\n  public get miterLimit(): f64 {\r\n    return LOAD<f64>(this._miterLimitStack, <i32>this._stackOffset);\r\n  }\r\n\r\n  public set miterLimit(value: f64) {\r\n    if (!isFinite(value) || value < 0) return;\r\n    STORE<f64>(this._miterLimitStack, <i32>this._stackOffset, value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current miterLimit value on the _miterLimitStack to the\r\n   * buffer if it currently does not match the last written miterLimit value.\r\n   */\r\n  @inline\r\n  private _updateMiterLimit(): void {\r\n    var value: f64 = LOAD<f64>(this._miterLimitStack, <i32>this._stackOffset);\r\n    if (value != this._currentMiterLimit) {\r\n      this._currentMiterLimit = value;\r\n      super._writeOne(CanvasInstruction.MiterLimit, value);\r\n    }\r\n  }\r\n  //#endregion MITERLIMIT\r\n\r\n  //#region SHADOWBLUR\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of f64 values.\r\n   */\r\n  private _shadowBlurStack: ArrayBuffer = new ArrayBuffer(0xFF * sizeof<f64>());\r\n\r\n  /**\r\n   * A private member that contains a single float value that represents the last shadowBlur value\r\n   * written by a drawing operation.\r\n   */\r\n  private _currentShadowBlur: f64 = 0.0;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.shadowBlur property of the Canvas 2D API specifies the amount of\r\n   * blur applied to shadows. The default is 0 (no blur).\r\n   *\r\n   * The shadowBlur value is a non-negative float specifying the level of shadow blur, where 0\r\n   * represents no blur and larger numbers represent increasingly more blur. This value doesn't\r\n   * correspond to a number of pixels, and is not affected by the current transformation matrix. The\r\n   * default value is 0. Negative, Infinity, and NaN values are ignored.\r\n   */\r\n  public get shadowBlur(): f64 {\r\n    return LOAD<f64>(this._shadowBlurStack, <i32>this._stackOffset);\r\n  }\r\n\r\n  public set shadowBlur(value: f64) {\r\n    if (!isFinite(value) || value < 0) return;\r\n    STORE<f64>(this._shadowBlurStack, <i32>this._stackOffset, value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current shadowBlur value on the _shadowBlurStack to the\r\n   * buffer if it currently does not match the last written shadowBlur value.\r\n   */\r\n  @inline\r\n  private _updateShadowBlur(): void {\r\n    var value: f64 = LOAD<f64>(this._shadowBlurStack, <i32>this._stackOffset);\r\n    if (value != this._currentShadowBlur) {\r\n      this._currentShadowBlur = value;\r\n      super._writeOne(CanvasInstruction.ShadowBlur, value);\r\n    }\r\n  }\r\n  //#endregion SHADOWBLUR\r\n\r\n  //#region SHADOWCOLOR\r\n  /**\r\n   * An ArrayBuffer that contains 256 pointers to shadowColor strings.\r\n   */\r\n  private _shadowColorStack: ArrayBuffer = setArrayBufferValue<usize>(\r\n    new ArrayBuffer(0xFF * sizeof<usize>()),\r\n    changetype<usize>(defaultShadowColor),\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single StrokeShadowColorType value that represents the last\r\n   * shadowColor value written by a drawing operation\r\n   */\r\n  private _currentShadowColor: string = defaultShadowColor;\r\n\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.shadowColor property of the Canvas 2D API specifies the current text\r\n   * representing a CSS Color\r\n   */\r\n  public get shadowColor(): string {\r\n    return changetype<string>(LOAD<usize>(this._shadowColorStack, this._stackOffset));\r\n  }\r\n\r\n  public set shadowColor(value: string) {\r\n    if (value == null) value = defaultShadowColor;\r\n    STORE<usize>(this._shadowColorStack, this._stackOffset, changetype<usize>(value));\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current shadowColor value on the _shadowColorStack to the\r\n   * buffer if it currently does not match the last written shadowColor.\r\n   */\r\n  @inline\r\n  private _updateShadowColor(): void {\r\n    var value: string = changetype<string>(LOAD<usize>(this._shadowColorStack, <i32>this._stackOffset));\r\n    if (value != this._currentShadowColor) {\r\n      this._currentFilter = value;\r\n      super._writeOne(CanvasInstruction.ShadowColor, changetype<usize>(value));\r\n    }\r\n  }\r\n  //#endregion\r\n\r\n  //#region SHADOWOFFSETX\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of f64 values.\r\n   */\r\n  private _shadowOffsetXStack: ArrayBuffer = new ArrayBuffer(0xFF * sizeof<f64>());\r\n\r\n  /**\r\n   * A private member that contains a single float value that represents the last shadowOffsetX value\r\n   * written by a drawing operation.\r\n   */\r\n  private _currentShadowOffsetX: f64 = 0.0;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.shadowOffsetX property of the Canvas 2D API specifies the distance\r\n   * that shadows will be offset horizontally.\r\n   *\r\n   * The value is a f64 specifying the distance that shadows will be offset horizontally. Positive\r\n   * values are to the right, and negative to the left. The default value is 0 (no horizontal\r\n   * offset). Infinity and NaN values are ignored.\r\n   */\r\n  public get shadowOffsetX(): f64 {\r\n    return LOAD<f64>(this._shadowOffsetXStack, <i32>this._stackOffset);\r\n  }\r\n\r\n  public set shadowOffsetX(value: f64) {\r\n    if (!isFinite(value)) return;\r\n    STORE<f64>(this._shadowOffsetXStack, <i32>this._stackOffset, value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current shadowOffsetX value on the _shadowOffsetXStack to the\r\n   * buffer if it currently does not match the last written shadowOffsetX value.\r\n   */\r\n  @inline\r\n  private _updateShadowOffsetX(): void {\r\n    var value: f64 = LOAD<f64>(this._shadowOffsetXStack, <i32>this._stackOffset);\r\n    if (value != this._currentShadowOffsetX) {\r\n      this._currentShadowOffsetX = value;\r\n      super._writeOne(CanvasInstruction.ShadowOffsetX, value);\r\n    }\r\n  }\r\n  //#endregion SHADOWOFFSETX\r\n\r\n  //#region SHADOWOFFSETY\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of f64 values.\r\n   */\r\n  private _shadowOffsetYStack: ArrayBuffer = new ArrayBuffer(0xFF * sizeof<f64>());\r\n\r\n  /**\r\n   * A private member that contains a single float value that represents the last shadowOffsetY value\r\n   * written by a drawing operation.\r\n   */\r\n  private _currentShadowOffsetY: f64 = 0.0;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.shadowOffsetY property of the Canvas 2D API specifies the distance\r\n   * that shadows will be offset vertically.\r\n   *\r\n   * The value is a f64 specifying the distance that shadows will be offset horizontally. Positive\r\n   * values are down, and negative are up. The default value is 0 (no vertical offset). Infinity and\r\n   * NaN values are ignored\r\n   */\r\n  public get shadowOffsetY(): f64 {\r\n    return LOAD<f64>(this._shadowOffsetYStack, <i32>this._stackOffset);\r\n  }\r\n\r\n  public set shadowOffsetY(value: f64) {\r\n    if (!isFinite(value)) return;\r\n    STORE<f64>(this._shadowOffsetYStack, <i32>this._stackOffset, value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current shadowOffsetY value on the _shadowOffsetYStack to the\r\n   * buffer if it currently does not match the last written shadowOffsetY value.\r\n   */\r\n  @inline\r\n  private _updateShadowOffsetY(): void {\r\n    var value: f64 = LOAD<f64>(this._shadowOffsetYStack, <i32>this._stackOffset);\r\n    if (value != this._currentShadowOffsetY) {\r\n      this._currentShadowOffsetY = value;\r\n      super._writeOne(CanvasInstruction.ShadowOffsetY, value);\r\n    }\r\n  }\r\n  //#endregion SHADOWOFFSETY\r\n\r\n  //#region STROKESTYLE\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of 2 usize values. For each strokeStyle, if the strokeStyle is\r\n   * a string, the second i32 value will be a pointer, otherwise, it's a `usize` representing the\r\n   * style's external objectID.\r\n   */\r\n  private _strokeStyleStack: ArrayBuffer = setArrayBufferValue2<usize>(\r\n    new ArrayBuffer(0xFF * sizeof<usize>() * 2),\r\n    <usize>FillStrokeStyleType.String,\r\n    changetype<usize>(defaultBlack),\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single StrokeFillStyleType value that represents the last\r\n   * strokeStyle value written by a drawing operation\r\n   */\r\n  private _currentStrokeStyleType: FillStrokeStyleType = FillStrokeStyleType.String;\r\n\r\n  /**\r\n   * A private member that contains a single pointer or id value that represents the last\r\n   * strokeStyle value written by a drawing operation\r\n   */\r\n  private _currentStrokeStyleValue: usize = changetype<usize>(defaultBlack);\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.strokeStyle property of the Canvas 2D API specifies the color,\r\n   * gradient, or pattern to use for the strokes (outlines) around shapes. The default is #000\r\n   * (black).\r\n   */\r\n  public get strokeStyle(): string | null {\r\n    var index: i32 = this._stackOffset * 2;\r\n    var strokeStyleType: FillStrokeStyleType = <FillStrokeStyleType>LOAD<usize>(\r\n      this._strokeStyleStack,\r\n      index,\r\n    );\r\n    if (strokeStyleType == FillStrokeStyleType.String) {\r\n      return changetype<string>(LOAD<usize>(this._strokeStyleStack, index + 1));\r\n    }\r\n    return null;\r\n  }\r\n\r\n  public set strokeStyle(value: string | null) {\r\n    if (value == null) value = defaultBlack;\r\n    var index: i32 = this._stackOffset * 2;\r\n    var buff: ArrayBuffer = this._strokeStyleStack;\r\n    STORE<usize>(buff, index, <usize>FillStrokeStyleType.String);\r\n    STORE<usize>(buff, index + 1, changetype<usize>(value));\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current strokeStyle value on the _strokeStyleStack to the\r\n   * buffer if it currently does not match the last written strokeStyle.\r\n   */\r\n  @inline\r\n  private _updateStrokeStyle(): void {\r\n    var buff: ArrayBuffer = this._strokeStyleStack;\r\n    var index: i32 = <i32>this._stackOffset * 2;\r\n    var styleType: FillStrokeStyleType = <FillStrokeStyleType>LOAD<usize>(buff, index);\r\n    var value: usize = LOAD<usize>(buff, index + 1);\r\n    if (styleType != this._currentStrokeStyleType || value != this._currentStrokeStyleValue) {\r\n      var inst: CanvasInstruction;\r\n      if (styleType == FillStrokeStyleType.String) inst = CanvasInstruction.StrokeStyle;\r\n      else if (styleType == FillStrokeStyleType.CanvasGradient) inst = CanvasInstruction.StrokeGradient;\r\n      else inst = CanvasInstruction.StrokePattern;\r\n      super._writeOne(inst, <f64>value);\r\n    }\r\n  }\r\n  //#endregion STROKESTYLE\r\n\r\n  //#region STROKEPATTERN\r\n  /**\r\n   * The CanvasRenderingContext2D.strokePattern property of the Canvas 2D API specifies pattern to\r\n   * use for the strokes (outlines) around shapes. The default is null.\r\n   */\r\n  public get strokePattern(): CanvasPattern | null {\r\n    var index: i32 = this._stackOffset * 2;\r\n    var buff: ArrayBuffer = this._strokeStyleStack;\r\n    var strokeStyleType: FillStrokeStyleType = <FillStrokeStyleType>LOAD<i32>(\r\n      buff,\r\n      index,\r\n    );\r\n\r\n    if (strokeStyleType == FillStrokeStyleType.CanvasPattern) {\r\n      var result: CanvasPattern = new CanvasPattern();\r\n      store<i32>(\r\n        changetype<usize>(result) + offsetof<CanvasPattern>(\"id\"),\r\n        LOAD<i32>(buff, index + 1),\r\n      );\r\n      return result;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  public set strokePattern(value: CanvasPattern | null) {\r\n    if (value == null) {\r\n      this.strokeStyle = defaultBlack;\r\n      return;\r\n    }\r\n    var index: i32 = this._stackOffset * 2;\r\n    var buff: ArrayBuffer = this._strokeStyleStack;\r\n    STORE<i32>(buff, index, FillStrokeStyleType.CanvasPattern);\r\n    STORE<i32>(buff, index + 1, load<i32>(changetype<usize>(value) + offsetof<CanvasPattern>(\"id\")));\r\n  }\r\n  //#endregion STROKEPATTERN\r\n\r\n  //#region STROKEGRADIENT\r\n  /**\r\n   * The CanvasRenderingContext2D.strokeGradient property of the Canvas 2D API specifies the\r\n   * gradient to use for the strokes (outlines) around shapes. The default is null.\r\n   */\r\n  public get strokeGradient(): CanvasGradient | null {\r\n    var index: i32 = this._stackOffset * 2;\r\n    var buff: ArrayBuffer = this._strokeStyleStack;\r\n    var strokeStyleType: FillStrokeStyleType = <FillStrokeStyleType>LOAD<i32>(\r\n      buff,\r\n      index,\r\n    );\r\n    if (strokeStyleType == FillStrokeStyleType.CanvasGradient) {\r\n      var result: CanvasGradient = new CanvasGradient();\r\n      store<i32>(\r\n        changetype<usize>(result) + offsetof<CanvasGradient>(\"id\"),\r\n        LOAD<i32>(buff, index + 1),\r\n      );\r\n      return result;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  public set strokeGradient(value: CanvasGradient | null) {\r\n    if (value == null) {\r\n      this.strokeStyle = defaultBlack;\r\n      return;\r\n    }\r\n    var index: i32 = this._stackOffset * 2;\r\n    var buff: ArrayBuffer = this._strokeStyleStack;\r\n    STORE<i32>(buff, index, FillStrokeStyleType.CanvasGradient);\r\n    STORE<i32>(buff, index + 1, load<i32>(changetype<usize>(value) + offsetof<CanvasGradient>(\"id\")));\r\n  }\r\n  //#endregion STROKEGRADIENT\r\n\r\n  //#region TEXTALIGN\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of TextAlign values.\r\n   */\r\n  private _textAlignStack: ArrayBuffer = setArrayBufferValue<TextAlign>(\r\n    new ArrayBuffer(0xFF * sizeof<TextAlign>()),\r\n    TextAlign.start,\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single LineCap value that represents the last\r\n   * lineCap value written by a drawing operation.\r\n   */\r\n  private _currentTextAlign: TextAlign = TextAlign.start;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.textAlign property of the Canvas 2D API specifies the current text\r\n   * alignment used when drawing text.\r\n   *\r\n   * The alignment is relative to the x value of the fillText() method. For example, if textAlign is\r\n   * \"center\", then the text's left edge will be at x - (textWidth / 2).\r\n   */\r\n  public get textAlign(): TextAlign {\r\n    return LOAD<TextAlign>(this._textAlignStack, <i32>this._stackOffset);\r\n  }\r\n\r\n  public set textAlign(value: TextAlign) {\r\n    STORE<TextAlign>(this._textAlignStack, <i32>this._stackOffset, value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current textAlign value on the _textAlignStack to the\r\n   * buffer if it currently does not match the last written textAlign value.\r\n   */\r\n  @inline\r\n  private _updateTextAlign(): void {\r\n    var value: TextAlign = LOAD<TextAlign>(\r\n      this._textAlignStack,\r\n      <i32>this._stackOffset,\r\n    );\r\n    if (value != this._currentTextAlign) {\r\n      this._currentTextAlign = value;\r\n      super._writeOne(CanvasInstruction.TextAlign, <f64>value);\r\n    }\r\n  }\r\n  //#endregion TEXTALIGN\r\n\r\n  //#region TEXTBASELINE\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of TextBaseline values.\r\n   */\r\n  private _textBaselineStack: ArrayBuffer = setArrayBufferValue<TextBaseline>(\r\n    new ArrayBuffer(0xFF * sizeof<TextBaseline>()),\r\n    TextBaseline.alphabetic,\r\n  );\r\n\r\n  /**\r\n   * A private member that contains a single LineCap value that represents the last\r\n   * lineCap value written by a drawing operation.\r\n   */\r\n  private _currentTextBaseline: TextBaseline = TextBaseline.alphabetic;\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.textBaseline property of the Canvas 2D API specifies the current\r\n   * text baseline used when drawing text.\r\n   */\r\n  public get textBaseline(): TextBaseline {\r\n    return LOAD<TextBaseline>(this._textBaselineStack, <i32>this._stackOffset);\r\n  }\r\n\r\n  public set textBaseline(value: TextBaseline) {\r\n    STORE<TextBaseline>(this._textBaselineStack, <i32>this._stackOffset, value);\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the current textBaseline value on the _textBaselineStack to the\r\n   * buffer if it currently does not match the last written textBaseline value.\r\n   */\r\n  @inline\r\n  private _updateTextBaseline(): void {\r\n    var value: TextBaseline = LOAD<TextBaseline>(\r\n      this._textBaselineStack,\r\n      <i32>this._stackOffset,\r\n    );\r\n    if (value != this._currentTextBaseline) {\r\n      this._currentTextBaseline = value;\r\n      super._writeOne(CanvasInstruction.TextBaseline, <f64>value);\r\n    }\r\n  }\r\n  //#endregion TEXTBASELINE\r\n\r\n  //#region SAVE\r\n  /**\r\n   * An ArrayBuffer that contains 256 sets of bool values.\r\n   */\r\n  private _saveStack: ArrayBuffer = new ArrayBuffer(0xFF * sizeof<bool>());\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.save() method of the Canvas 2D API saves the entire state of the\r\n   * canvas by pushing the current state onto a stack.\r\n   *\r\n   * The drawing state that gets saved onto a stack consists of:\r\n   *\r\n   * - The current transformation matrix.\r\n   * - The current clipping region.\r\n   * - The current dash list.\r\n   * - The current values of the following attributes: strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled.\r\n   *\r\n   * @param {bool} hard - Tells the context to perform an actual `save()` operation. Default value is false.\r\n   */\r\n  public save(hard: bool = false): void {\r\n    var offset: i32 = <i32>this._stackOffset;\r\n    var nextOffset: i32 = offset + 1;\r\n    if (nextOffset >= <i32>u8.MAX_VALUE) unreachable();\r\n    var transformIndex: i32 = offset * 6;\r\n    var nextTransformIndex: i32 = transformIndex + 6;\r\n    var styleIndex: i32 = offset << 1;\r\n    var nextStyleIndex = styleIndex + 2;\r\n\r\n    // currentTransform\r\n    var target: ArrayBuffer = this._transformStack;\r\n    STORE<f64>(target, nextTransformIndex, LOAD<f64>(target, transformIndex));\r\n    STORE<f64>(target, nextTransformIndex + 1, LOAD<f64>(target, transformIndex + 1));\r\n    STORE<f64>(target, nextTransformIndex + 2, LOAD<f64>(target, transformIndex + 2));\r\n    STORE<f64>(target, nextTransformIndex + 3, LOAD<f64>(target, transformIndex + 3));\r\n    STORE<f64>(target, nextTransformIndex + 4, LOAD<f64>(target, transformIndex + 4));\r\n    STORE<f64>(target, nextTransformIndex + 5, LOAD<f64>(target, transformIndex + 5));\r\n\r\n    // direction\r\n    target = this._directionStack;\r\n    STORE<CanvasDirection>(target, nextOffset, LOAD<CanvasDirection>(target, offset));\r\n\r\n    // fillStyle\r\n    target = this._fillStyleStack;\r\n    STORE<usize>(target, nextStyleIndex, LOAD<usize>(target, styleIndex));\r\n    STORE<usize>(target, nextStyleIndex + 1, LOAD<usize>(target, styleIndex + 1));\r\n\r\n    // filter\r\n    target = this._filterStack;\r\n    STORE<usize>(target, nextOffset, LOAD<usize>(target, offset));\r\n\r\n    // font\r\n    target = this._fontStack;\r\n    STORE<usize>(target, nextOffset, LOAD<usize>(target, offset));\r\n\r\n    // globalAlpha\r\n    target = this._globalAlphaStack;\r\n    STORE<f64>(target, nextOffset, LOAD<f64>(target, offset));\r\n\r\n    // globalCompositeOperation\r\n    target = this._globalCompositeOperationStack;\r\n    STORE<GlobalCompositeOperation>(target, nextOffset, LOAD<GlobalCompositeOperation>(target, offset));\r\n\r\n    // imageSmoothingEnabled\r\n    target = this._imageSmoothingEnabledStack;\r\n    STORE<bool>(target, nextOffset, LOAD<bool>(target, offset));\r\n\r\n    // imageSmoothingQuality\r\n    target = this._imageSmoothingQualityStack;\r\n    STORE<ImageSmoothingQuality>(target, nextOffset, LOAD<ImageSmoothingQuality>(target, offset));\r\n\r\n    // lineCap\r\n    target = this._lineCapStack;\r\n    STORE<LineCap>(target, nextOffset, LOAD<LineCap>(target, offset));\r\n\r\n    // lineDash\r\n\r\n    /**\r\n     * Whenever a save occurs, if it would overwrite a reference that already exists, we must free\r\n     * it manually.\r\n     */\r\n    var nextLineDash: usize = LOAD<usize>(this._lineDashStack, nextOffset);\r\n    if (changetype<Float64Array>(nextLineDash) != null) {\r\n      // always free the underlying buffer FIRST\r\n      memory.free(changetype<usize>(changetype<Float64Array>(nextLineDash).buffer));\r\n      memory.free(nextLineDash);\r\n    }\r\n\r\n    STORE<usize>(this._lineDashStack, nextOffset, changetype<usize>(null));\r\n\r\n    // lineDashOffset\r\n    target = this._lineDashOffsetStack;\r\n    STORE<f64>(target, nextOffset, LOAD<f64>(target, offset));\r\n\r\n    // lineJoin\r\n    target = this._lineJoinStack;\r\n    STORE<LineJoin>(target, nextOffset, LOAD<LineJoin>(target, offset));\r\n\r\n    // lineWidth\r\n    target = this._lineWidthStack;\r\n    STORE<f64>(target, nextOffset, LOAD<f64>(target, offset));\r\n\r\n    // miterLimit\r\n    target = this._miterLimitStack;\r\n    STORE<f64>(target, nextOffset, LOAD<f64>(target, offset));\r\n\r\n    // shadowBlur\r\n    target = this._shadowBlurStack;\r\n    STORE<f64>(target, nextOffset, LOAD<f64>(target, offset));\r\n\r\n    // shadowColor\r\n    target = this._shadowColorStack;\r\n    STORE<usize>(target, nextOffset, LOAD<usize>(target, offset));\r\n\r\n    // shadowOffsetX\r\n    target = this._shadowOffsetXStack;\r\n    STORE<f64>(target, nextOffset, LOAD<f64>(target, offset));\r\n\r\n    // shadowOffsetY\r\n    target = this._shadowOffsetYStack;\r\n    STORE<f64>(target, nextOffset, LOAD<f64>(target, offset));\r\n\r\n    // strokeStyle\r\n    target = this._strokeStyleStack;\r\n    STORE<usize>(target, nextStyleIndex, LOAD<usize>(target, styleIndex));\r\n    STORE<usize>(target, nextStyleIndex + 1, LOAD<usize>(target, styleIndex + 1));\r\n\r\n    // textBaseline\r\n    target = this._textBaselineStack;\r\n    STORE<TextBaseline>(target, nextOffset, LOAD<TextBaseline>(target, offset));\r\n\r\n    // textAlign\r\n    target = this._textAlignStack;\r\n    STORE<TextAlign>(target, nextOffset, LOAD<TextAlign>(target, offset));\r\n\r\n    if (hard) {\r\n      STORE<bool>(this._saveStack, nextOffset, true);\r\n      super._writeZero(CanvasInstruction.Save);\r\n    }\r\n\r\n    this._stackOffset = <u8>nextOffset;\r\n  }\r\n  //#endregion SAVE\r\n\r\n  //#region RESTORE\r\n  /**\r\n   * The CanvasRenderingContext2D.restore() method of the Canvas 2D API restores the most recently\r\n   * saved canvas state by popping the top entry in the drawing state stack. If there is no saved\r\n   * state, this method does nothing.\r\n   *\r\n   * In the case of the hard restore, this function will mirror what the browser does, and modifies\r\n   * the last written values instead of just moving the stack pointer. This ensures that the writer\r\n   * emulates the browser state machine as accurately as possible.\r\n   */\r\n  public restore(): void {\r\n    if (this._stackOffset == <u8>0) return;\r\n    var currentOffset: i32 = <i32>this._stackOffset;\r\n    var nextOffset: i32 = currentOffset - 1;\r\n    var styleOffset: i32 = nextOffset * 2;\r\n    var target: ArrayBuffer;\r\n    var source: ArrayBuffer;\r\n    var transformOffset: i32 = nextOffset * 6;\r\n\r\n    if (LOAD<bool>(this._saveStack, currentOffset)) {\r\n      target = this._currentTransform;\r\n      source = this._transformStack;\r\n\r\n      // transformCurrent\r\n      STORE<f64>(target, 0, LOAD<f64>(source, transformOffset));\r\n      STORE<f64>(target, 1, LOAD<f64>(source, transformOffset + 1));\r\n      STORE<f64>(target, 2, LOAD<f64>(source, transformOffset + 2));\r\n      STORE<f64>(target, 3, LOAD<f64>(source, transformOffset + 3));\r\n      STORE<f64>(target, 4, LOAD<f64>(source, transformOffset + 4));\r\n      STORE<f64>(target, 5, LOAD<f64>(source, transformOffset + 5));\r\n\r\n      // direction\r\n      this._currentDirection = LOAD<CanvasDirection>(this._directionStack, nextOffset);\r\n\r\n      // fillStyle\r\n      source = this._fillStyleStack;\r\n      this._currentFillStyleType = <FillStrokeStyleType>LOAD<usize>(source, styleOffset);\r\n      this._currentFillStyleValue = LOAD<usize>(source, styleOffset + 1);\r\n\r\n      // filter\r\n      this._currentFilter = changetype<string>(LOAD<usize>(this._filterStack, nextOffset));\r\n\r\n      // font\r\n      this._currentFont = changetype<string>(LOAD<usize>(this._fontStack, nextOffset));\r\n\r\n      // globalAlpha\r\n      this._currentGlobalAlpha = LOAD<f64>(this._globalAlphaStack, nextOffset);\r\n\r\n      // globalCompositeOperation\r\n      this._currentGlobalCompositeOperation = LOAD<GlobalCompositeOperation>(this._globalCompositeOperationStack, nextOffset);\r\n\r\n      // imageSmoothingEnabled\r\n      this._currentImageSmoothingEnabled = LOAD<bool>(this._imageSmoothingEnabledStack, nextOffset);\r\n\r\n      // imageSmoothingQuality\r\n      this._currentImageSmoothingQuality = LOAD<ImageSmoothingQuality>(this._imageSmoothingQualityStack, nextOffset);\r\n\r\n      // lineCap\r\n      this._currentLineCap = LOAD<LineCap>(this._lineCapStack, nextOffset);\r\n\r\n      // lineDash\r\n      this._currentLineDash = changetype<Float64Array>(LOAD<usize>(this._lineDashStack, nextOffset));\r\n\r\n      // lineDashOffset\r\n      this._currentLineDashOffset = LOAD<f64>(this._lineDashOffsetStack, nextOffset);\r\n\r\n      // lineJoin\r\n      this._currentLineJoin = LOAD<LineJoin>(this._lineJoinStack, nextOffset);\r\n\r\n      // lineWidth\r\n      this._currentLineWidth = LOAD<f64>(this._lineWidthStack, nextOffset);\r\n\r\n      // miterLimit\r\n      this._currentMiterLimit = LOAD<f64>(this._miterLimitStack, nextOffset);\r\n\r\n      // shadowBlur\r\n      this._currentShadowBlur = LOAD<f64>(this._shadowBlurStack, nextOffset);\r\n\r\n      // shadowColor\r\n      this._currentShadowColor = changetype<string>(LOAD<usize>(this._shadowColorStack, nextOffset));\r\n\r\n      // shadowOffsetX\r\n      this._currentShadowOffsetX = LOAD<f64>(this._shadowOffsetXStack, nextOffset);\r\n\r\n      // shadowOffsetY\r\n      this._currentShadowOffsetY = LOAD<f64>(this._shadowOffsetYStack, nextOffset);\r\n\r\n      // strokeStyle\r\n      source = this._strokeStyleStack;\r\n      this._currentStrokeStyleType = <FillStrokeStyleType>LOAD<usize>(source, styleOffset);\r\n      this._currentStrokeStyleValue = LOAD<usize>(source, styleOffset + 1);\r\n\r\n      // textAlign\r\n      this._currentTextAlign = LOAD<TextAlign>(this._textAlignStack, nextOffset);\r\n\r\n      // textBaseline\r\n      this._currentTextBaseline = LOAD<TextBaseline>(this._textBaselineStack, nextOffset);\r\n      super._writeZero(CanvasInstruction.Restore);\r\n    }\r\n\r\n    this._stackOffset = <u8>nextOffset;\r\n  }\r\n  //#endregion RESTORE\r\n\r\n  //#region PATH\r\n  /**\r\n   * An internal array of path items.\r\n   */\r\n  private _path: Path2DElement[] = createPathElements();\r\n\r\n  /**\r\n   * The path offset is an index that always points to the next path index to be written to.\r\n   * Every time beginPath is called, this value should be set to 1.\r\n   */\r\n  private _pathOffset: i32 = 1;\r\n\r\n  /**\r\n   * The path buffer offset is an index that always points to the next path item to be written to\r\n   * the buffer. Every time beginPath is called, this value should be set to 0.\r\n   */\r\n  private _pathBufferOffset: i32 = 0;\r\n\r\n  /**\r\n   * An internal function that writes a single path item to the _path. \r\n   *\r\n   * @param {CanvasInstruction} inst - The CanvasInstruction that represents the current pathing\r\n   * operation that should be written to the path buffer.\r\n   * @param {bool} updateTransform - The bool value that determines if the PathElement should store\r\n   * the _currentTransform values.\r\n   * @param {i32} count - The number of parameters for this PathElement's instruction.\r\n   * @param {f64} a - The first parameter for this PathElement's instruction.\r\n   * @param {f64} b - The second parameter for this PathElement's instruction.\r\n   * @param {f64} c - The third parameter for this PathElement's instruction.\r\n   * @param {f64} d - The fourth parameter for this PathElement's instruction.\r\n   * @param {f64} e - The five parameter for this PathElement's instruction.\r\n   * @param {f64} f - The six parameter for this PathElement's instruction.\r\n   * @param {f64} g - The seven parameter for this PathElement's instruction.\r\n   * @param {f64} h - The eighth parameter for this PathElement's instruction.\r\n   */\r\n  @inline\r\n  private _writePath(\r\n    inst: CanvasInstruction,\r\n    updateTransform: bool = false,\r\n    count: i32 = 0,\r\n    a: f64 = 0.0,\r\n    b: f64 = 0.0,\r\n    c: f64 = 0.0,\r\n    d: f64 = 0.0,\r\n    e: f64 = 0.0,\r\n    f: f64 = 0.0,\r\n    g: f64 = 0.0,\r\n    h: f64 = 0.0,\r\n  ): void {\r\n    var el: Path2DElement = unchecked(this._path[this._pathOffset]);\r\n    var index: i32;\r\n    var current: ArrayBuffer;\r\n    el.instruction = inst;\r\n    el.updateTransform = updateTransform;\r\n    if (updateTransform) {\r\n      index = this._stackOffset * 6;\r\n      current = this._transformStack;\r\n      el.transformA = LOAD<f64>(current, index + 0);\r\n      el.transformB = LOAD<f64>(current, index + 1);\r\n      el.transformC = LOAD<f64>(current, index + 2);\r\n      el.transformD = LOAD<f64>(current, index + 3);\r\n      el.transformE = LOAD<f64>(current, index + 4);\r\n      el.transformF = LOAD<f64>(current, index + 5);\r\n    }\r\n    el.count = count;\r\n    el.a = a;\r\n    el.b = b;\r\n    el.c = c;\r\n    el.d = d;\r\n    el.e = e;\r\n    el.f = f;\r\n    el.g = g;\r\n    el.h = h;\r\n    ++this._pathOffset;\r\n  }\r\n\r\n  /**\r\n   * An internal function that writes the queued up path items to the buffer. It optionally calls\r\n   * setTransform if the transform was modified between path calls.\r\n   */\r\n  @inline\r\n  private _updatePath(): void {\r\n    var end: i32 = this._pathOffset;\r\n    var el: Path2DElement;\r\n    var a: f64;\r\n    var b: f64;\r\n    var c: f64;\r\n    var d: f64;\r\n    var e: f64;\r\n    var f: f64;\r\n    var current: ArrayBuffer = this._currentTransform;\r\n    for (var i: i32 = this._pathBufferOffset; i <= end; i++) {\r\n      el = unchecked(this._path[i]);\r\n      if (el.updateTransform) {\r\n        a = el.transformA;\r\n        b = el.transformB;\r\n        c = el.transformC;\r\n        d = el.transformD;\r\n        e = el.transformE;\r\n        f = el.transformF;\r\n\r\n        if (\r\n          a != LOAD<f64>(current, 0) ||\r\n          b != LOAD<f64>(current, 1) ||\r\n          c != LOAD<f64>(current, 2) ||\r\n          d != LOAD<f64>(current, 3) ||\r\n          e != LOAD<f64>(current, 4) ||\r\n          f != LOAD<f64>(current, 5)\r\n        ) {\r\n          super._writeSix(CanvasInstruction.SetTransform, a, b, c, d, e, f);\r\n          STORE<f64>(current, 0, a);\r\n          STORE<f64>(current, 1, b);\r\n          STORE<f64>(current, 2, c);\r\n          STORE<f64>(current, 3, d);\r\n          STORE<f64>(current, 4, e);\r\n          STORE<f64>(current, 5, f);\r\n        }\r\n        switch (el.count) {\r\n          case 0: {\r\n            super._writeZero(el.instruction);\r\n            break;\r\n          }\r\n          case 1: {\r\n            super._writeOne(el.instruction, el.a);\r\n            break;\r\n          }\r\n          case 2: {\r\n            super._writeTwo(el.instruction, el.a, el.b);\r\n            break;\r\n          }\r\n          case 4: {\r\n            super._writeFour(el.instruction, el.a, el.b, el.c, el.d);\r\n            break;\r\n          }\r\n          case 5: {\r\n            super._writeFive(el.instruction, el.a, el.b, el.c, el.d, el.e);\r\n            break;\r\n          }\r\n          case 6: {\r\n            super._writeSix(el.instruction, el.a, el.b, el.c, el.d, el.e, el.f);\r\n            break;\r\n          }\r\n          case 8: {\r\n            super._writeEight(el.instruction, el.a, el.b, el.c, el.d, el.e, el.f, el.g, el.h);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  //#endregion PATH\r\n\r\n  //#region ARC\r\n  /**\r\n   * The CanvasRenderingContext2D.arc() method of the Canvas 2D API adds a circular arc to\r\n   * the current sub-path.\r\n   *\r\n   * @param {f64} x - The x-axis (horizontal) coordinate of the arc's center.\r\n   * @param {f64} y - The y-axis (vertical) coordinate of the arc's center.\r\n   * @param {f64} radius - The arc's radius. Must be non-negative.\r\n   * @param {f64} startAngle - The angle at which the arc starts, measured clockwise from the positive x-axis\r\n   * and expressed in radians.\r\n   * @param {f64} endAngle - The angle at which the arc ends, measured clockwise from the positive x-axis and\r\n   * expressed in radians.\r\n   * @param {bool} anticlockwise - An optional bool which, if true, causes the arc to be drawn\r\n   * counter-clockwise between the start and end angles. The default value is false (clockwise).\r\n   */\r\n  public arc(x: f64, y: f64, radius: f64, startAngle: f64, endAngle: f64 , anticlockwise: bool = false): void {\r\n    if (!isFinite(x + y + radius + startAngle + endAngle) || radius < 0) return;\r\n    this._writePath(CanvasInstruction.Arc, true, 6, x, y, radius, startAngle, endAngle, anticlockwise ? 1.0 : 0.0);\r\n  }\r\n  //#endregion ARC\r\n\r\n  //#region ARCTO\r\n  /**\r\n   * The CanvasRenderingContext2D.arcTo() method of the Canvas 2D API adds a circular arc to the current\r\n   * sub-path, using the given control points and radius. The arc is automatically connected to the\r\n   * path's latest point with a straight line, if necessary for the specified parameters. This method is\r\n   * commonly used for making rounded corners.\r\n   *\r\n   * @param {f64} x1 - The x-axis coordinate of the first control point.\r\n   * @param {f64} y1 - The y-axis coordinate of the first control point.\r\n   * @param {f64} x2 - The x-axis coordinate of the second control point.\r\n   * @param {f64} y2 - The y-axis coordinate of the second control point.\r\n   * @param {f64} radius - The arc's radius. Must be non-negative.\r\n   */\r\n  public arcTo(x1: f64, y1: f64, x2: f64, y2: f64, radius: f64): void {\r\n    if (!isFinite(x1 + y1 + x2 + y2 + radius) || radius < 0) return;\r\n    this._writePath(CanvasInstruction.ArcTo, true, 5, x1, y1, x2, y2, radius);\r\n  }\r\n  //#endregion ARCTO\r\n\r\n  //#region BEGINPATH\r\n  /**\r\n   * The CanvasRenderingContext2D.beginPath() method of the Canvas 2D API starts a new path by\r\n   * emptying the list of sub-paths. Call this method when you want to create a new path.\r\n   */\r\n  public beginPath(): void {\r\n    this._pathOffset = 1;\r\n    this._pathBufferOffset = 0;\r\n  }\r\n  //#endregion BEGINPATH\r\n\r\n  //#region BEZIERCURVETO\r\n  /**\r\n   * The CanvasRenderingContext2D.bezierCurveTo() method of the Canvas 2D API adds a cubic Bzier\r\n   * curve to the current sub-path. It requires three points: the first two are control points and\r\n   * the third one is the end point. The starting point is the latest point in the current path, which\r\n   * can be changed using moveTo() before creating the Bzier curve.\r\n   *\r\n   * @param {f64} cp1x - The x-axis coordinate of the first control point.\r\n   * @param {f64} cp1y - The y-axis coordinate of the first control point.\r\n   * @param {f64} cp2x - The x-axis coordinate of the second control point.\r\n   * @param {f64} cp2y - The y-axis coordinate of the second control point.\r\n   * @param {f64} x - The x-axis coordinate of the end point.\r\n   * @param {f64} y - The y-axis coordinate of the end point.\r\n   */\r\n  public bezierCurveTo(cp1x: f64, cp1y: f64, cp2x: f64, cp2y: f64, x: f64, y: f64): void {\r\n    if (!isFinite(cp1x + cp1y + cp2x + cp2y + x + y)) return;\r\n    this._writePath(CanvasInstruction.BezierCurveTo, true, 6, cp1x, cp1y, cp2x, cp2y, x, y);\r\n  }\r\n  //#endregion BEZIERCURVETO\r\n\r\n  //#region CLEARRECT\r\n  /**\r\n   * The CanvasRenderingContext2D.clearRect() method of the Canvas 2D API erases the pixels in a\r\n   * rectangular area by setting them to transparent black.\r\n   *\r\n   * @param {f64} x - The x-axis coordinate of the rectangle's starting point.\r\n   * @param {f64} y - The y-axis coordinate of the rectangle's starting point.\r\n   * @param {f64} width - The rectangle's width. Positive values are to the right, and negative to\r\n   * the left.\r\n   * @param {f64} height - The rectangle's height. Positive values are down, and negative are up.\r\n   */\r\n  public clearRect(x: f64, y: f64, width: f64, height: f64): void {\r\n    if (!isFinite(x + y + width + height)) return;\r\n    this._updateTransform();\r\n    super._writeFour(CanvasInstruction.ClearRect, x, y, width, height);\r\n  }\r\n  //#endregion CLEARRECT\r\n\r\n  //#region CLIP\r\n  /**\r\n   * The CanvasRenderingContext2D.clip() method of the Canvas 2D API turns the current or given path\r\n   * into the current clipping region. It replaces any previous clipping region. In the image below,\r\n   * the red outline represents a clipping region shaped like a star. Only those parts of the\r\n   * checkerboard pattern that are within the clipping region get drawn.\r\n   */\r\n  public clip(): void {\r\n    this._updatePath();\r\n    super._writeZero(CanvasInstruction.Clip);\r\n  }\r\n  //#endregion CLIP\r\n\r\n  //#region CLOSEPATH\r\n  /**\r\n   * The CanvasRenderingContext2D.closePath() method of the Canvas 2D API attempts to add a straight\r\n   * line from the current point to the start of the current sub-path. If the shape has already been\r\n   * closed or has only one point, this function does nothing. This method doesn't draw anything to\r\n   * the canvas directly. You can render the path using the stroke() or fill() methods.\r\n   */\r\n  public closePath(): void {\r\n    if (this._pathOffset == 1 || this._lastPathItem.instruction === CanvasInstruction.ClosePath) return;\r\n    this._writePath(CanvasInstruction.ClosePath, true, 0);\r\n  }\r\n\r\n  @inline\r\n  private get _lastPathItem(): Path2DElement {\r\n    return unchecked(this._path[this._pathOffset - 1]);\r\n  }\r\n  //#endregion CLOSEPATH\r\n\r\n  //#region DRAWIMAGE\r\n  /**\r\n   * The CanvasRenderingContext2D.drawImagePosition() method of the Canvas 2D API provides a simple\r\n   * method for drawing an image onto the canvas at a specific position.\r\n   *\r\n   * @param {Image} image - An element to draw into the context. The specification permits any canvas\r\n   * image source (Image).\r\n   * @param {f64} dx - The x-axis coordinate in the destination canvas at which to place the top-left\r\n   * corner of the source image.\r\n   * @param {f64} dy - The y-axis coordinate in the destination canvas at which to place the top-left\r\n   * corner of the source image.\r\n   */\r\n  public drawImage(image: Image, dx: f64, dy: f64): void {\r\n    if (image == null || !isFinite(dx + dy) || !image.loaded) return;\r\n    this._updateFilter();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateTransform();\r\n    this._writeNine(\r\n      CanvasInstruction.DrawImage,\r\n      <f64>getImageID(image),\r\n      0.0, 0.0, <f64>image.width, <f64>image.height,\r\n      dx, dy, <f64>image.width, <f64>image.height,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.drawImageSize() method of the Canvas 2D API provides a simple\r\n   * method for drawing an image onto the canvas at a specific position.\r\n   *\r\n   * @param {Image} image - An element to draw into the context. The specification permits any canvas\r\n   * image source (Image).\r\n   * @param {f64} dx - The x-axis coordinate in the destination canvas at which to place the top-left\r\n   * corner of the source image.\r\n   * @param {f64} dy - The y-axis coordinate in the destination canvas at which to place the top-left\r\n   * corner of the source image.\r\n   * @param {f64} dWidth - The width to draw the image in the destination canvas. This allows scaling\r\n   * of the drawn image. If not specified, the image is not scaled in width when drawn.\r\n   * @param {f64} dHeight - The height to draw the image in the destination canvas. This allows scaling\r\n   * of the drawn image. If not specified, the image is not scaled in height when drawn.\r\n   */\r\n  public drawImageSize(image: Image, dx: f64, dy: f64, dWidth: f64, dHeight: f64): void {\r\n    if (image == null || !isFinite(dx + dy + dWidth + dHeight) || !image.loaded) return;\r\n    this._updateFilter();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateTransform();\r\n    this._writeNine(\r\n      CanvasInstruction.DrawImage,\r\n      <f64>getImageID(image),\r\n      0.0, 0.0, <f64>image.width, <f64>image.height,\r\n      dx, dy, dWidth, dHeight,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D.drawImageSource() method of the Canvas 2D API provides a simple\r\n   * method for drawing an image onto the canvas at a specific position.\r\n   *\r\n   * @param {Image} image - An element to draw into the context. The specification permits any canvas\r\n   * image source (Image).\r\n   * @param {f64} sx - The x-axis coordinate of the top left corner of the sub-rectangle of the source\r\n   * image to draw into the destination context.\r\n   * @param {f64} sy - The y-axis coordinate of the top left corner of the sub-rectangle of the source\r\n   * image to draw into the destination context.\r\n   * @param {f64} sWidth - The width of the sub-rectangle of the source image to draw into the\r\n   * destination context. If not specified, the entire rectangle from the coordinates specified by sx\r\n   * and sy to the bottom-right corner of the image is used.\r\n   * @param {f64} sHeight - The height of the sub-rectangle of the source image to draw into the\r\n   * destination context.\r\n   * @param {f64} dx - The x-axis coordinate in the destination canvas at which to place the top-left\r\n   * corner of the source image.\r\n   * @param {f64} dy - The y-axis coordinate in the destination canvas at which to place the top-left\r\n   * corner of the source image.\r\n   * @param {f64} dWidth - The width to draw the image in the destination canvas. This allows scaling\r\n   * of the drawn image. If not specified, the image is not scaled in width when drawn.\r\n   * @param {f64} dHeight - The height to draw the image in the destination canvas. This allows scaling\r\n   * of the drawn image. If not specified, the image is not scaled in height when drawn.\r\n   */\r\n  public drawImageSource(image: Image, sx: f64, sy: f64, sWidth: f64, sHeight: f64, dx: f64, dy: f64, dWidth: f64, dHeight: f64): void {\r\n    if (image == null || !isFinite(sx + sy + sWidth + sHeight + dx + dy + dWidth + dHeight) || !image.loaded) return;\r\n    this._updateFilter();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateTransform();\r\n    this._writeNine(\r\n      CanvasInstruction.DrawImage,\r\n      <f64>getImageID(image),\r\n      sx, sy, sWidth, sHeight,\r\n      dx, dy, dWidth, dHeight,\r\n    );\r\n  }\r\n  //#endregion DRAWIMAGE\r\n\r\n  //#region ELLIPSE\r\n  /**\r\n   * The CanvasRenderingContext2D.ellipse() method of the Canvas 2D API adds an elliptical arc to the current sub-path.\r\n   *\r\n   * @param {f64} x - The x-axis (horizontal) coordinate of the ellipse's center.\r\n   * @param {f64} y - The y-axis (vertical) coordinate of the ellipse's center.\r\n   * @param {f64} radiusX - The ellipse's major-axis radius. Must be non-negative.\r\n   * @param {f64} radiusY - The ellipse's minor-axis radius. Must be non-negative.\r\n   * @param {f64} rotation - The rotation of the ellipse, expressed in radians.\r\n   * @param {f64} startAngle - The angle at which the ellipse starts, measured clockwise from the positive x-axis\r\n   * and expressed in radians.\r\n   * @param {f64} endAngle - The angle at which the ellipse ends, measured clockwise from the positive x-axis and\r\n   * expressed in radians.\r\n   * @param {bool} anticlockwise - An optional Boolean which, if true, draws the ellipse anticlockwise\r\n   * (counter-clockwise). The default value is false (clockwise).\r\n   */\r\n  public ellipse(x: f64, y: f64, radiusX: f64, radiusY: f64, rotation: f64, startAngle: f64, endAngle: f64, anticlockwise: bool = false): void {\r\n    if (!isFinite(x + y + radiusX + radiusY + rotation + startAngle + endAngle) || radiusX < 0 || radiusY < 0) return;\r\n    this._writePath(\r\n      CanvasInstruction.Ellipse,\r\n      true, 8,\r\n      x, y, radiusX, radiusY,\r\n      rotation, startAngle, endAngle, anticlockwise ? 1.0 : 0.0,\r\n    );\r\n  }\r\n  //#endregion ELLIPSE\r\n\r\n  //#region FILL\r\n  /**\r\n   * The CanvasRenderingContext2D.fill() method of the Canvas 2D API fills the current or given path\r\n   * with the current fillStyle.\r\n   *\r\n   * @param {FillRule} fillRule - The algorithm by which to determine if a point is inside or\r\n   * outside the filling region.\r\n   *\r\n   * Possible values:\r\n   * - `FillRule.nonzero`: The non-zero winding rule. Default rule.\r\n   * - `FillRule.evenodd`: The even-odd winding rule.\r\n   */\r\n  public fill(fillRule: FillRule = FillRule.nonzero): void {\r\n    /**\r\n     * If there are no items on the path, there is no reason to fill. Index 1 means the path buffer\r\n     * is pointing to a single `beginPath()` operation and it does not matter if fill is called at\r\n     * this point.\r\n     */\r\n    if (this._pathOffset == 1) return;\r\n    this._updateFillStyle();\r\n    this._updateFilter();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n\r\n    /**\r\n     * This function must be called *before* _updateTransform(), because both the path operations and the\r\n     * fill operations affect the transform. Each pathing operation has it's own transform, and the\r\n     * transform value when the fill operation occurs might be different.\r\n     */\r\n    this._updatePath();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateTransform();\r\n    super._writeOne(CanvasInstruction.Fill, <f64>fillRule);\r\n  }\r\n  //#endregion FILL\r\n\r\n  //#region FILLRECT\r\n  /**\r\n   * The CanvasRenderingContext2D.fillRect() method of the Canvas 2D API draws a rectangle that is\r\n   * filled according to the current fillStyle. This method draws directly to the canvas without\r\n   * modifying the current path, so any subsequent fill() or stroke() calls will have no effect on\r\n   * it.\r\n   *\r\n   * @param x - The x-axis coordinate of the rectangle's starting point.\r\n   * @param y - The y-axis coordinate of the rectangle's starting point.\r\n   * @param width - The rectangle's width. Positive values are to the right, and negative to the\r\n   * left.\r\n   * @param height - The rectangle's height. Positive values are down, and negative are up.\r\n   */\r\n  public fillRect(x: f64, y: f64, width: f64, height: f64): void {\r\n    if (!isFinite(x + y + width + height)) return;\r\n    this._updateFillStyle();\r\n    this._updateFilter();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateTransform();\r\n    super._writeFour(CanvasInstruction.FillRect, x, y, width, height);\r\n  }\r\n  //#endregion FILLRECT\r\n\r\n  //#region FILLTEXT\r\n  /**\r\n   * The CanvasRenderingContext2D method fillText(), part of the Canvas 2D API, draws a text string\r\n   * at the specified coordinates, filling the string's characters with the current fillStyle. An\r\n   * optional parameter allows specifying a maximum width for the rendered text, which the user\r\n   * agent will achieve by condensing the text or by using a lower font size. This method draws\r\n   * directly to the canvas without modifying the current path, so any subsequent fill() or stroke()\r\n   * calls will have no effect on it. The text is rendered using the font and text layout\r\n   * configuration as defined by the font, textAlign, textBaseline, and direction properties.\r\n   *\r\n   * The fillText function can accept an optional maxWidth property. Use the fillTextWidth function\r\n   * to enable the use of that parameter.\r\n   *\r\n   * @param text - A DOMString specifying the text string to render into the context. The text is\r\n   * rendered using the settings specified by font, textAlign, textBaseline, and direction.\r\n   * @param x - The x-axis coordinate of the point at which to begin drawing the text, in pixels.\r\n   * @param y - The y-axis coordinate of the point at which to begin drawing the text, in pixels.\r\n   */\r\n  public fillText(text: string, x: f64, y: f64): void {\r\n    if (!isFinite(x + y) || text == null || text.length == 0) return;\r\n    this._updateDirection();\r\n    this._updateFillStyle();\r\n    this._updateFilter();\r\n    this._updateFont();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateTextAlign();\r\n    this._updateTextBaseline();\r\n    this._updateTransform();\r\n    super._writeThree(CanvasInstruction.FillText, <f64>changetype<usize>(text), x, y);\r\n  }\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D method fillText(), part of the Canvas 2D API, draws a text string\r\n   * at the specified coordinates, filling the string's characters with the current fillStyle. An\r\n   * optional parameter allows specifying a maximum width for the rendered text, which the user\r\n   * agent will achieve by condensing the text or by using a lower font size. This method draws\r\n   * directly to the canvas without modifying the current path, so any subsequent fill() or stroke()\r\n   * calls will have no effect on it. The text is rendered using the font and text layout\r\n   * configuration as defined by the font, textAlign, textBaseline, and direction properties.\r\n   *\r\n   * The fillText function can accept an optional maxWidth property. Use the fillTextWidth function\r\n   * to enable the use of that parameter.\r\n   *\r\n   * @param text - A DOMString specifying the text string to render into the context. The text is\r\n   * rendered using the settings specified by font, textAlign, textBaseline, and direction.\r\n   * @param x - The x-axis coordinate of the point at which to begin drawing the text, in pixels.\r\n   * @param y - The y-axis coordinate of the point at which to begin drawing the text, in pixels.\r\n   * @param maxWidth - The maximum number of pixels wide the text may be once rendered. If not\r\n   * specified, there is no limit to the width of the text. However, if this value is provided, the\r\n   * user agent will adjust the kerning, select a more horizontally condensed font (if one is available or can be generated without loss of quality), or scale down to a smaller font size in order to fit the text in the specified width.\r\n   */\r\n  public fillTextWidth(text: string, x: f64, y: f64, maxWidth: f64): void {\r\n    if (!isFinite(x + y + maxWidth) || text == null || text.length == 0 || maxWidth < 0) return;\r\n    this._updateDirection();\r\n    this._updateFillStyle();\r\n    this._updateFilter();\r\n    this._updateFont();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateTextAlign();\r\n    this._updateTextBaseline();\r\n    this._updateTransform();\r\n    super._writeFour(CanvasInstruction.FillTextWidth, <f64>changetype<usize>(text), x, y, maxWidth);\r\n  }\r\n  //#endregion FILLTEXT\r\n\r\n  //#region ISPOINTINPATH\r\n  /**\r\n   * The CanvasRenderingContext2D.isPointInPath() method of the Canvas 2D API reports whether or not\r\n   * the specified point is contained in the current path. It forces a commit to flush all the\r\n   * current instructions to the buffer, updates the path, and then performs a pointInPath function\r\n   * call on the canvas.\r\n   *\r\n   * @param {f64} x - The x-axis coordinate of the point to check.\r\n   * @param {f64} y - The y-axis coordinate of the point to check.\r\n   * @param {FillRule} fillRule - The algorithm by which to determine if a point is inside or\r\n   * outside the path.\r\n   *\r\n   * Possible values:\r\n   * - `FillRule.nonzero`: The non-zero winding rule. Default rule.\r\n   * - `FillRule.evenodd`: The even-odd winding rule.\r\n   */\r\n  public isPointInPath(x: f64, y: f64, fillRule: FillRule = FillRule.nonzero): bool {\r\n    if (!isFinite(x + y)) return false;\r\n    this._updatePath();\r\n    this.commit();\r\n    return isPointInPath(this.id, x, y, fillRule);\r\n  }\r\n  //#endregion ISPOINTINPATH\r\n\r\n  //#region ISPOINTINSTROKE\r\n  /**\r\n   * The CanvasRenderingContext2D.isPointInStroke() method of the Canvas 2D API reports whether or\r\n   * not the specified point is inside the area contained by the stroking of a path. It forces a\r\n   * commit to flush all the current instructions to the buffer, updates the path, and then performs\r\n   * a pointInPath function call on the canvas.\r\n   *\r\n   * @param {f64} x - The x-axis coordinate of the point to check.\r\n   * @param {f64} y - The y-axis coordinate of the point to check.\r\n   */\r\n  public isPointInStroke(x: f64, y: f64): bool {\r\n    if (!isFinite(x + y)) return false;\r\n    this._updatePath();\r\n    this.commit();\r\n    return isPointInStroke(this.id, x, y);\r\n  }\r\n  //#endregion ISPOINTINSTROKE\r\n\r\n  //#region LINETO\r\n  /**\r\n   * The CanvasRenderingContext2D method lineTo(), part of the Canvas 2D API, adds a straight line\r\n   * to the current sub-path by connecting the sub-path's last point to the specified (x, y)\r\n   * coordinates. Like other methods that modify the current path, this method does not directly\r\n   * render anything. To draw the path onto a canvas, you can use the fill() or stroke() methods.\r\n   *\r\n   * @param {f64} x - The x-axis coordinate of the line's end point.\r\n   * @param {f64} y - The y-axis coordinate of the line's end point.\r\n   */\r\n  public lineTo(x: f64, y: f64): void {\r\n    if (!isFinite(x + y)) return;\r\n    this._writePath(CanvasInstruction.LineTo, true, 2, x, y);\r\n  }\r\n  //#endregion LINETO\r\n\r\n  //#region MEASURETEXT\r\n  /**\r\n   * The CanvasRenderingContext2D.measureText() method returns a TextMetrics object that contains\r\n   * information about the measured text (such as its width, for example). The as2d implementation\r\n   * only returns the resulting width property value.\r\n   *\r\n   * @param {string} text - The text string to measure.\r\n   */\r\n  public measureText(text: string): f64 {\r\n    this._updateFont();\r\n    this.commit();\r\n    return measureText(this.id, text);\r\n  }\r\n  //#endregion MEASURETEXT\r\n\r\n  //#region MOVETO\r\n  /**\r\n   * The CanvasRenderingContext2D.moveTo() method of the Canvas 2D API begins a new sub-path at the\r\n   * point specified by the given (x, y) coordinates.\r\n   *\r\n   * @param {f64} x - The x-axis (horizontal) coordinate of the point.\r\n   * @param {f64} y - The y-axis (vertical) coordinate of the point.\r\n   */\r\n  public moveTo(x: f64, y: f64): void {\r\n    if (!isFinite(x + y)) return;\r\n    this._writePath(CanvasInstruction.MoveTo, true, 2, x, y);\r\n  }\r\n  //#endregion MOVETO\r\n\r\n  //#region QUADRATICCURVETO\r\n  /**\r\n   * The CanvasRenderingContext2D.quadraticCurveTo() method of the Canvas 2D API adds a quadratic\r\n   * Bzier curve to the current sub-path. It requires two points: the first one is a control point\r\n   * and the second one is the end point. The starting point is the latest point in the current\r\n   * path, which can be changed using moveTo() before creating the quadratic Bzier curve.\r\n   *\r\n   * @param cpx - The x-axis coordinate of the control point.\r\n   * @param cpy - The y-axis coordinate of the control point.\r\n   * @param x - The x-axis coordinate of the end point.\r\n   * @param y - The y-axis coordinate of the end point.\r\n   */\r\n  public quadraticCurveTo(cpx: f64, cpy: f64, x: f64, y: f64): void {\r\n    if (!isFinite(cpx + cpy + x + y)) return;\r\n    this._writePath(CanvasInstruction.QuadraticCurveTo, true, 4, cpx, cpy, x, y);\r\n  }\r\n  //#endregion QUADRATICCURVETO\r\n\r\n  //#region RECT\r\n  /**\r\n   * The CanvasRenderingContext2D.rect() method of the Canvas 2D API adds a rectangle to the current\r\n   * path. Like other methods that modify the current path, this method does not directly render\r\n   * anything. To draw the rectangle onto a canvas, you can use the fill() or stroke() methods.\r\n   *\r\n   * @param {f64} x - The x-axis coordinate of the rectangle's starting point.\r\n   * @param {f64} y - The y-axis coordinate of the rectangle's starting point.\r\n   * @param {f64} width - The rectangle's width. Positive values are to the right, and negative to\r\n   * the left.\r\n   * @param {f64} height - The rectangle's height. Positive values are down, and negative are up.\r\n   */\r\n  public rect(x: f64, y: f64, width: f64, height: f64): void {\r\n    if (!isFinite(x + y + width + height)) return;\r\n    this._writePath(CanvasInstruction.Rect, true, 4, x, y, width, height);\r\n  }\r\n  //#endregion RECT\r\n\r\n  //#region RESETTRANSFORM\r\n  /**\r\n   * The CanvasRenderingContext2D.resetTransform() method of the Canvas 2D API resets the current\r\n   * transform to the identity matrix.\r\n   */\r\n  public resetTransform(): void {\r\n    this.setTransform(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);\r\n  }\r\n  //#endregion RESETTRANSFORM\r\n\r\n  //#region ROTATE\r\n  /**\r\n   * The CanvasRenderingContext2D.rotate() method of the Canvas 2D API adds a rotation to the\r\n   * transformation matrix.\r\n   *\r\n   * @param {f64} angle - The rotation angle, clockwise in radians. You can use\r\n   * `degree * Math.PI / 180` if you want to calculate from a degree value.\r\n   */\r\n  public rotate(angle: f64): void {\r\n    if (!isFinite(angle)) return;\r\n    var index: i32 = this._stackOffset * 6;\r\n    var current: ArrayBuffer = this._transformStack;\r\n    var a: f64 = LOAD<f64>(current, index);\r\n    var b: f64 = LOAD<f64>(current, index + 1);\r\n    var c: f64 = LOAD<f64>(current, index + 2);\r\n    var d: f64 = LOAD<f64>(current, index + 3);\r\n    var cos: f64 = Math.cos(angle);\r\n    var sin: f64 = Math.sin(angle);\r\n    STORE<f64>(current, index, a * cos + c * sin);\r\n    STORE<f64>(current, index + 1, b * cos + d * sin);\r\n    STORE<f64>(current, index + 2, c * cos - a * sin);\r\n    STORE<f64>(current, index + 3, d * cos - b * sin);\r\n  }\r\n  //#endregion ROTATE\r\n\r\n  //#region SCALE\r\n  /**\r\n   * The CanvasRenderingContext2D.scale() method of the Canvas 2D API adds a scaling transformation\r\n   * to the canvas units horizontally and/or vertically. By default, one unit on the canvas is\r\n   * exactly one pixel. A scaling transformation modifies this behavior. For instance, a scaling\r\n   * factor of 0.5 results in a unit size of 0.5 pixels; shapes are thus drawn at half the normal\r\n   * size. Similarly, a scaling factor of 2.0 increases the unit size so that one unit becomes two\r\n   * pixels; shapes are thus drawn at twice the normal size.\r\n   *\r\n   * @param {f64} x - Scaling factor in the horizontal direction. A negative value flips pixels\r\n   * across the vertical axis. A value of 1 results in no horizontal scaling.\r\n   * @param {f64} y - Scaling factor in the vertical direction. A negative value flips pixels across\r\n   * the horizontal axis. A value of 1 results in no vertical scaling.\r\n   */\r\n  public scale(x: f64, y: f64): void {\r\n    if (!isFinite(x + y)) return;\r\n    var index: i32 = this._stackOffset * 6;\r\n    var current: ArrayBuffer = this._transformStack;\r\n    STORE<f64>(current, index, LOAD<f64>(current, index) * x);\r\n    STORE<f64>(current, index + 1, LOAD<f64>(current, index + 1) * x);\r\n    STORE<f64>(current, index + 2, LOAD<f64>(current, index + 2) * y);\r\n    STORE<f64>(current, index + 3, LOAD<f64>(current, index + 3) * y);\r\n  }\r\n  //#endregion SCALE\r\n\r\n  //#region SETTRANSFORM\r\n  /**\r\n   * The CanvasRenderingContext2D.setTransform() method of the Canvas 2D API resets (overrides) the\r\n   * current transformation to the identity matrix, and then invokes a transformation described by\r\n   * the arguments of this method. This lets you scale, rotate, translate (move), and skew the\r\n   * context.\r\n   *\r\n   * @param {f64} a - Horizontal scaling. A value of 1 results in no scaling.\r\n   * @param {f64} b - Vertical skewing.\r\n   * @param {f64} c - Horizontal skewing.\r\n   * @param {f64} d - Vertical scaling. A value of 1 results in no scaling.\r\n   * @param {f64} e - Horizontal translation (moving).\r\n   * @param {f64} f - Vertical translation (moving).\r\n   */\r\n  public setTransform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    if (!isFinite(a + b + c + d + e + f)) return ;\r\n    var index: i32 = this._stackOffset * 6;\r\n    var current: ArrayBuffer = this._transformStack;\r\n    STORE<f64>(current, index, a);\r\n    STORE<f64>(current, index + 1, b);\r\n    STORE<f64>(current, index + 2, c);\r\n    STORE<f64>(current, index + 3, d);\r\n    STORE<f64>(current, index + 4, e);\r\n    STORE<f64>(current, index + 5, f);\r\n  }\r\n  //#endregion SETTRANSFORM\r\n\r\n  //#region STROKE\r\n  /**\r\n   * The CanvasRenderingContext2D.stroke() method of the Canvas 2D API strokes (outlines) the\r\n   * current or given path with the current stroke style. Strokes are aligned to the center of a\r\n   * path; in other words, half of the stroke is drawn on the inner side, and half on the outer\r\n   * side. The stroke is drawn using the non-zero winding rule, which means that path intersections\r\n   * will still get filled.\r\n   */\r\n  public stroke(): void {\r\n    /**\r\n     * If there are no items on the path, there is no reason to fill. Index 1 means the path buffer\r\n     * is pointing to a single `beginPath()` operation and it does not matter if fill is called at\r\n     * this point.\r\n     */\r\n    if (this._pathOffset == 1) return;\r\n    /**\r\n     * If the lineWidth is zero, there is no line and it does not matter if ctx.stroke() is called.\r\n     */\r\n    if (LOAD<f64>(this._lineWidthStack, this._stackOffset) <= 0.0) return;\r\n    this._updateFilter();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateLineCap();\r\n    this._updateLineDash();\r\n    this._updateLineDashOffset();\r\n    this._updateLineJoin();\r\n    this._updateLineWidth();\r\n    this._updateMiterLimit();\r\n    this._updatePath();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateStrokeStyle();\r\n    this._updateTransform();\r\n    super._writeZero(CanvasInstruction.Stroke);\r\n  }\r\n  //#endregion STROKE\r\n\r\n  //#region STROKERECT\r\n  /**\r\n   * The CanvasRenderingContext2D.strokeRect() method of the Canvas 2D API draws a rectangle that is\r\n   * stroked (outlined) according to the current strokeStyle and other context settings. This method\r\n   * draws directly to the canvas without modifying the current path, so any subsequent fill() or\r\n   * stroke() calls will have no effect on it.\r\n   *\r\n   * @param {f64} x - The x-axis coordinate of the rectangle's starting point.\r\n   * @param {f64} y - The y-axis coordinate of the rectangle's starting point.\r\n   * @param {f64} width - The rectangle's width. Positive values are to the right, and negative to\r\n   * the left.\r\n   * @param {f64} height - The rectangle's height. Positive values are down, and negative are up.\r\n   */\r\n  public strokeRect(x: f64, y: f64, width: f64, height: f64): void {\r\n    /**\r\n     * If the lineWidth is zero, there is no line and it does not matter if ctx.stroke() is called.\r\n     */\r\n    if (LOAD<f64>(this._lineWidthStack, this._stackOffset) <= 0.0) return;\r\n    this._updateFilter();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateLineCap();\r\n    this._updateLineDash();\r\n    this._updateLineDashOffset();\r\n    this._updateLineJoin();\r\n    this._updateLineWidth();\r\n    this._updateMiterLimit();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateStrokeStyle();\r\n    this._updateTransform();\r\n    super._writeFour(CanvasInstruction.StrokeRect, x, y, width, height);\r\n  }\r\n  //#endregion STROKERECT\r\n\r\n  //#region STROKETEXT\r\n  /**\r\n   * The CanvasRenderingContext2D method strokeText(), part of the Canvas 2D API, strokes  that is,\r\n   * draws the outlines of  the characters of a text string at the specified coordinates. An\r\n   * optional parameter allows specifying a maximum width for the rendered text, which the user\r\n   * agent will achieve by condensing the text or by using a lower font size. This method draws\r\n   * directly to the canvas without modifying the current path, so any subsequent fill() or stroke()\r\n   * calls will have no effect on it. To use the maxWidth parameter, use the strokeTextWidth\r\n   * function.\r\n   *\r\n   * @param {string} text - A DOMString specifying the text string to render into the context. The\r\n   * text is rendered using the settings specified by font, textAlign, textBaseline, and direction.\r\n   * @param {f64} x - The x-axis coordinate of the point at which to begin drawing the text.\r\n   * @param {f64} y - The y-axis coordinate of the point at which to begin drawing the text.\r\n   */\r\n  public strokeText(text: string, x: f64, y: f64): void {\r\n    this._updateDirection();\r\n    this._updateFilter();\r\n    this._updateFont();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateLineCap();\r\n    this._updateLineDash();\r\n    this._updateLineDashOffset();\r\n    this._updateLineJoin();\r\n    this._updateLineWidth();\r\n    this._updateMiterLimit();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateStrokeStyle();\r\n    this._updateTextAlign();\r\n    this._updateTextBaseline();\r\n    this._updateTransform();\r\n    super._writeThree(CanvasInstruction.StrokeText, <f64>changetype<usize>(text), x, y)\r\n  }\r\n\r\n  /**\r\n   * The CanvasRenderingContext2D method strokeTextWidth(), part of the Canvas 2D API, strokes \r\n   * that is, draws the outlines of  the characters of a text string at the specified coordinates.\r\n   * An optional parameter allows specifying a maximum width for the rendered text, which the user\r\n   * agent will achieve by condensing the text or by using a lower font size. This method draws\r\n   * directly to the canvas without modifying the current path, so any subsequent fill() or stroke()\r\n   * calls will have no effect on it. To use the maxWidth parameter, use the strokeTextWidth\r\n   * function.\r\n   *\r\n   * @param {string} text - A DOMString specifying the text string to render into the context. The\r\n   * text is rendered using the settings specified by font, textAlign, textBaseline, and direction.\r\n   * @param {f64} x - The x-axis coordinate of the point at which to begin drawing the text.\r\n   * @param {f64} y - The y-axis coordinate of the point at which to begin drawing the text.\r\n   * @param {f64} maxWidth - The maximum width the text may be once rendered. If not specified,\r\n   * there is no limit to the width of the text. However, if this value is provided, the user agent\r\n   * will adjust the kerning, select a more horizontally condensed font (if one is available or can\r\n   * be generated without loss of quality), or scale down to a smaller font size in order to fit the\r\n   * text in the specified width.\r\n   */\r\n  public strokeTextWidth(text: string, x: f64, y: f64, maxWidth: f64): void {\r\n    this._updateDirection();\r\n    this._updateFilter();\r\n    this._updateFont();\r\n    this._updateGlobalAlpha();\r\n    this._updateGlobalCompositeOperation();\r\n    this._updateImageSmoothingEnabled();\r\n    this._updateImageSmoothingQuality();\r\n    this._updateLineCap();\r\n    this._updateLineDash();\r\n    this._updateLineDashOffset();\r\n    this._updateLineJoin();\r\n    this._updateLineWidth();\r\n    this._updateMiterLimit();\r\n    this._updateShadowBlur();\r\n    this._updateShadowColor();\r\n    this._updateShadowOffsetX();\r\n    this._updateShadowOffsetY();\r\n    this._updateStrokeStyle();\r\n    this._updateTextAlign();\r\n    this._updateTextBaseline();\r\n    this._updateTransform();\r\n    super._writeFour(CanvasInstruction.StrokeTextWidth, <f64>changetype<usize>(text), x, y, maxWidth);\r\n  }\r\n  //#endregion STROKETEXT\r\n\r\n  //#region TRANSFORM\r\n  /**\r\n   * The CanvasRenderingContext2D.transform() method of the Canvas 2D API multiplies the current\r\n   * transformation with the matrix described by the arguments of this method. This lets you scale,\r\n   * rotate, translate (move), and skew the context.\r\n   *\r\n   * @param {f64} a - Horizontal scaling. A value of 1 results in no scaling.\r\n   * @param {f64} b - Vertical skewing.\r\n   * @param {f64} c - Horizontal skewing.\r\n   * @param {f64} d - Vertical scaling. A value of 1 results in no scaling.\r\n   * @param {f64} e - Horizontal translation (moving).\r\n   * @param {f64} f - Vertical translation (moving).\r\n   */\r\n  public transform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    if (!isFinite(a + b + c + d + e + f)) return;\r\n    var current: ArrayBuffer = this._transformStack;\r\n    var index: i32 = this._stackOffset * 6;\r\n    var sa: f64 = LOAD<f64>(current, index);\r\n    var sb: f64 = LOAD<f64>(current, index + 1);\r\n    var sc: f64 = LOAD<f64>(current, index + 2);\r\n    var sd: f64 = LOAD<f64>(current, index + 3);\r\n    var se: f64 = LOAD<f64>(current, index + 4);\r\n    var sf: f64 = LOAD<f64>(current, index + 5);\r\n\r\n    STORE<f64>(current, index, sa * a + sc * b);\r\n    STORE<f64>(current, index + 1, sb * a + sd * b);\r\n    STORE<f64>(current, index + 2, sa * c + sc * d);\r\n    STORE<f64>(current, index + 3, sb * c + sd * d);\r\n    STORE<f64>(current, index + 4, sa * e + sc * f + se);\r\n    STORE<f64>(current, index + 5, sb * e + sd * f + sf);\r\n  }\r\n  //#endregion TRANSFORM\r\n\r\n  //#region TRANSLATE\r\n  /**\r\n   * The CanvasRenderingContext2D.translate() method of the Canvas 2D API adds a translation\r\n   * transformation to the current matrix.\r\n   * @param {f64} x - Distance to move in the horizontal direction. Positive values are to the\r\n   * right, and negative to the left.\r\n   * @param {f64} y - Distance to move in the vertical direction. Positive values are down, and\r\n   * negative are up.\r\n   */\r\n  public translate(x: f64, y: f64): void {\r\n    if (!isFinite(x + y)) return;\r\n\r\n    var current: ArrayBuffer = this._transformStack;\r\n    var index: i32 = this._stackOffset * 6;\r\n\r\n    // e = e + a * x + c * y;\r\n    STORE<f64>(\r\n      current,\r\n      index + 4,\r\n      LOAD<f64>(current, index + 4) + LOAD<f64>(current, index) * x + LOAD<f64>(current, index + 2) * y,\r\n    );\r\n\r\n    // f = f + b * x + d * y;\r\n    STORE<f64>(\r\n      current,\r\n      index + 5,\r\n      LOAD<f64>(current, index + 5) + LOAD<f64>(current, index + 1) * x + LOAD<f64>(current, index + 3) * y,\r\n    );\r\n  }\r\n  //#endregion TRANSLATE\r\n\r\n  public commit(): void {\r\n    super._writeZero(CanvasInstruction.Commit);\r\n    render(this.id, this._buffer.data);\r\n    super._resetBuffer();\r\n  }\r\n}\r\n","import { MAX_SIZE_32 } from \"./allocator\";\r\nimport { String } from \"../string\";\r\n\r\n/** Size of a String header. */\r\n@inline export const HEADER_SIZE = (offsetof<String>() + 1) & ~1; // 2 byte aligned\r\n/** Maximum length of a String. */\r\n@inline export const MAX_LENGTH = (<i32>MAX_SIZE_32 - HEADER_SIZE) >>> 1;\r\n\r\n// Low-level utility\r\n\r\nfunction __gc(ref: usize): void {}\r\n\r\nexport function allocateUnsafe(length: i32): String {\r\n  assert(length > 0 && length <= MAX_LENGTH);\r\n  var buffer: usize;\r\n  if (isManaged<String>()) {\r\n    buffer = __gc_allocate(HEADER_SIZE + (<usize>length << 1), __gc);  // tslint:disable-line\r\n  } else {\r\n    buffer = memory.allocate(HEADER_SIZE + (<usize>length << 1));\r\n  }\r\n  store<i32>(buffer, length);\r\n  return changetype<String>(buffer);\r\n}\r\n\r\n@inline\r\nexport function freeUnsafe(buffer: String): void {\r\n  if (!isManaged<String>()) {\r\n    assert(buffer);\r\n    memory.free(changetype<usize>(buffer));\r\n  }\r\n}\r\n\r\nexport function copyUnsafe(dest: String, destOffset: usize, src: String, srcOffset: usize, len: usize): void {\r\n  memory.copy(\r\n    changetype<usize>(dest) + (destOffset << 1) + HEADER_SIZE,\r\n    changetype<usize>(src)  + (srcOffset  << 1) + HEADER_SIZE,\r\n    len << 1\r\n  );\r\n}\r\n\r\nexport function compareUnsafe(str1: String, offset1: usize, str2: String, offset2: usize, len: usize): i32 {\r\n  var cmp: i32 = 0;\r\n  var ptr1 = changetype<usize>(str1) + (offset1 << 1);\r\n  var ptr2 = changetype<usize>(str2) + (offset2 << 1);\r\n  while (len && !(cmp = <i32>load<u16>(ptr1, HEADER_SIZE) - <i32>load<u16>(ptr2, HEADER_SIZE))) {\r\n    --len, ptr1 += 2, ptr2 += 2;\r\n  }\r\n  return cmp;\r\n}\r\n\r\nexport function repeatUnsafe(dest: String, destOffset: usize, src: String, count: i32): void {\r\n  var length = src.length;\r\n  if (ASC_SHRINK_LEVEL > 1) {\r\n    let strLen = length << 1;\r\n    let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\r\n    let from = changetype<usize>(src)  + HEADER_SIZE;\r\n    for (let i = 0, len = strLen * count; i < len; i += strLen) {\r\n      memory.copy(to + i, from, strLen);\r\n    }\r\n  } else {\r\n    switch (length) {\r\n      case 0: break;\r\n      case 1: {\r\n        let cc =  load<u16>(changetype<usize>(src), HEADER_SIZE);\r\n        let out = changetype<usize>(dest) + (destOffset << 1);\r\n        for (let i = 0; i < count; ++i) {\r\n          store<u16>(out + (i << 1), cc, HEADER_SIZE);\r\n        }\r\n        break;\r\n      }\r\n      case 2: {\r\n        let cc  = load<u32>(changetype<usize>(src), HEADER_SIZE);\r\n        let out = changetype<usize>(dest) + (destOffset << 1);\r\n        for (let i = 0; i < count; ++i) {\r\n          store<u32>(out + (i << 2), cc, HEADER_SIZE);\r\n        }\r\n        break;\r\n      }\r\n      case 3: {\r\n        let cc1 = load<u32>(changetype<usize>(src), HEADER_SIZE + 0);\r\n        let cc2 = load<u16>(changetype<usize>(src), HEADER_SIZE + 4);\r\n        let out = changetype<usize>(dest) + (destOffset << 1);\r\n        for (let i = 0; i < count; ++i) {\r\n          store<u32>(out + (i << 2), cc1, HEADER_SIZE + 0);\r\n          store<u16>(out + (i << 1), cc2, HEADER_SIZE + 4);\r\n        }\r\n        break;\r\n      }\r\n      case 4: {\r\n        let cc = load<u64>(changetype<usize>(src), HEADER_SIZE);\r\n        let out = changetype<usize>(dest) + (destOffset << 1);\r\n        for (let i = 0; i < count; ++i) {\r\n          store<u64>(out + (i << 3), cc, HEADER_SIZE);\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        let strLen = length << 1;\r\n        let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\r\n        let from = changetype<usize>(src)  + HEADER_SIZE;\r\n        for (let i = 0, len = strLen * count; i < len; i += strLen) {\r\n          memory.copy(to + i, from, strLen);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Helpers\r\n\r\n@inline export const enum CharCode {\r\n  PLUS = 0x2B,\r\n  MINUS = 0x2D,\r\n  DOT = 0x2E,\r\n  _0 = 0x30,\r\n  _1 = 0x31,\r\n  _2 = 0x32,\r\n  _3 = 0x33,\r\n  _4 = 0x34,\r\n  _5 = 0x35,\r\n  _6 = 0x36,\r\n  _7 = 0x37,\r\n  _8 = 0x38,\r\n  _9 = 0x39,\r\n  A = 0x41,\r\n  B = 0x42,\r\n  E = 0x45,\r\n  N = 0x4E,\r\n  O = 0x4F,\r\n  X = 0x58,\r\n  Z = 0x5a,\r\n  a = 0x61,\r\n  b = 0x62,\r\n  e = 0x65,\r\n  n = 0x6E,\r\n  o = 0x6F,\r\n  x = 0x78,\r\n  z = 0x7A\r\n}\r\n\r\nexport function isWhiteSpaceOrLineTerminator(c: u16): bool {\r\n  switch (c) {\r\n    case 9:    // <TAB>\r\n    case 10:   // <LF>\r\n    case 13:   // <CR>\r\n    case 11:   // <VT>\r\n    case 12:   // <FF>\r\n    case 32:   // <SP>\r\n    case 160:  // <NBSP>\r\n    case 8232: // <LS>\r\n    case 8233: // <PS>\r\n    case 65279: return true; // <ZWNBSP>\r\n    default: return false;\r\n  }\r\n}\r\n\r\n/** Parses a string to an integer (usually), using the specified radix. */\r\nexport function parse<T>(str: String, radix: i32 = 0): T {\r\n  var len: i32 = str.length;\r\n  if (!len) return <T>NaN;\r\n\r\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\r\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n\r\n  // determine sign\r\n  var sign: T;\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) return <T>NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) return <T>NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = 1;\r\n  } else {\r\n    sign = 1;\r\n  }\r\n\r\n  // determine radix\r\n  if (!radix) {\r\n    if (code == CharCode._0 && len > 2) {\r\n      switch (<i32>load<u16>(ptr + 2, HEADER_SIZE)) {\r\n        case CharCode.B:\r\n        case CharCode.b: {\r\n          ptr += 4; len -= 2;\r\n          radix = 2;\r\n          break;\r\n        }\r\n        case CharCode.O:\r\n        case CharCode.o: {\r\n          ptr += 4; len -= 2;\r\n          radix = 8;\r\n          break;\r\n        }\r\n        case CharCode.X:\r\n        case CharCode.x: {\r\n          ptr += 4; len -= 2;\r\n          radix = 16;\r\n          break;\r\n        }\r\n        default: radix = 10;\r\n      }\r\n    } else radix = 10;\r\n  } else if (radix < 2 || radix > 36) {\r\n    return <T>NaN;\r\n  }\r\n\r\n  // calculate value\r\n  var num: T = 0;\r\n  while (len--) {\r\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n    if (code >= CharCode._0 && code <= CharCode._9) {\r\n      code -= CharCode._0;\r\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\r\n      code -= CharCode.A - 10;\r\n    } else if (code >= CharCode.a && code <= CharCode.z) {\r\n      code -= CharCode.a - 10;\r\n    } else break;\r\n    if (code >= radix) break;\r\n    num = (num * radix) + code;\r\n    ptr += 2;\r\n  }\r\n  return sign * num;\r\n}\r\n","import {\r\n  HEADER_SIZE as AB_HEADER_SIZE,\r\n  MAX_BLENGTH as AB_MAX_BLENGTH,\r\n  allocateUnsafe,\r\n  LOAD,\r\n  STORE\r\n} from \"./arraybuffer\";\r\n\r\nimport {\r\n  SORT as SORT_IMPL\r\n} from \"./sort\";\r\n\r\n/** Typed array base class. Not a global object. */\r\nexport abstract class TypedArray<T> {\r\n  [key: number]: T; // compatibility only\r\n\r\n  readonly buffer: ArrayBuffer;\r\n  readonly byteOffset: i32;\r\n  readonly byteLength: i32;\r\n\r\n  constructor(length: i32) {\r\n    const MAX_LENGTH = <u32>AB_MAX_BLENGTH / sizeof<T>();\r\n    if (<u32>length > MAX_LENGTH) throw new RangeError(\"Invalid typed array length\");\r\n    var byteLength = length << alignof<T>();\r\n    var buffer = allocateUnsafe(byteLength);\r\n    memory.fill(changetype<usize>(buffer) + AB_HEADER_SIZE, 0, <usize>byteLength);\r\n    this.buffer = buffer;\r\n    this.byteOffset = 0;\r\n    this.byteLength = byteLength;\r\n  }\r\n\r\n  @inline\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<T>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  protected __get(index: i32): T {\r\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\r\n    return LOAD<T>(this.buffer, index, this.byteOffset);\r\n  }\r\n\r\n  @inline @operator(\"{}\")\r\n  protected __unchecked_get(index: i32): T {\r\n    return LOAD<T>(this.buffer, index, this.byteOffset);\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  protected __set(index: i32, value: native<T>): void {\r\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\r\n    STORE<T,native<T>>(this.buffer, index, value, this.byteOffset);\r\n  }\r\n\r\n  @inline @operator(\"{}=\")\r\n  protected __unchecked_set(index: i32, value: native<T>): void {\r\n    STORE<T,native<T>>(this.buffer, index, value, this.byteOffset);\r\n  }\r\n\r\n  // copyWithin(target: i32, start: i32, end: i32 = this.length): this\r\n}\r\n\r\n@inline\r\nexport function FILL<TArray extends TypedArray<T>, T extends number>(\r\n  array: TArray,\r\n  value: native<T>,\r\n  start: i32,\r\n  end: i32\r\n): TArray {\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  var len = array.length;\r\n  start = start < 0 ? max(len + start, 0) : min(start, len);\r\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\r\n  if (sizeof<T>() == 1) {\r\n    if (start < end) {\r\n      memory.fill(\r\n        changetype<usize>(buffer) + start + byteOffset + AB_HEADER_SIZE,\r\n        <u8>value,\r\n        <usize>(end - start)\r\n      );\r\n    }\r\n  } else {\r\n    for (; start < end; ++start) {\r\n      STORE<T,native<T>>(buffer, start, value, byteOffset);\r\n    }\r\n  }\r\n  return array;\r\n}\r\n\r\n@inline\r\nexport function SORT<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  comparator: (a: T, b: T) => i32\r\n): TArray {\r\n  var byteOffset = array.byteOffset;\r\n  var length = array.length;\r\n  if (length <= 1) return array;\r\n  var buffer = array.buffer;\r\n  if (length == 2) {\r\n    let a = LOAD<T>(buffer, 1, byteOffset);\r\n    let b = LOAD<T>(buffer, 0, byteOffset);\r\n    if (comparator(a, b) < 0) {\r\n      STORE<T>(buffer, 1, b, byteOffset);\r\n      STORE<T>(buffer, 0, a, byteOffset);\r\n    }\r\n    return array;\r\n  }\r\n  SORT_IMPL<T>(buffer, byteOffset, length, comparator);\r\n  return array;\r\n}\r\n\r\n@inline\r\nexport function SUBARRAY<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  begin: i32,\r\n  end: i32\r\n): TArray {\r\n  var length = <i32>array.length;\r\n  if (begin < 0) begin = max(length + begin, 0);\r\n  else begin = min(begin, length);\r\n  if (end < 0) end = max(length + end, begin);\r\n  else end = max(min(end, length), begin);\r\n  var slice = memory.allocate(offsetof<TArray>());\r\n  store<usize>(slice, array.buffer, offsetof<TArray>(\"buffer\"));\r\n  store<i32>(slice, <i32>array.byteOffset + (begin << alignof<T>()), offsetof<TArray>(\"byteOffset\"));\r\n  store<i32>(slice, (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\r\n  return changetype<TArray>(slice);\r\n}\r\n\r\n@inline\r\nexport function REDUCE<TArray extends TypedArray<T>, T, TRet>(\r\n  array: TArray,\r\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\r\n  initialValue: TRet\r\n): TRet {\r\n  var length = array.length;\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  for (let i = 0; i < length; i++) {\r\n    initialValue = callbackfn(\r\n      initialValue,\r\n      LOAD<T>(buffer, i, byteOffset),\r\n      i,\r\n      array,\r\n    );\r\n  }\r\n  return initialValue;\r\n}\r\n\r\n@inline\r\nexport function REDUCE_RIGHT<TArray extends TypedArray<T>, T, TRet>(\r\n  array: TArray,\r\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\r\n  initialValue: TRet\r\n): TRet {\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  for (let i = array.length - 1; i >= 0; i--) {\r\n    initialValue = callbackfn(\r\n      initialValue,\r\n      LOAD<T>(buffer, i, byteOffset),\r\n      i,\r\n      array,\r\n    );\r\n  }\r\n  return initialValue;\r\n}\r\n\r\n@inline\r\nexport function MAP<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  callbackfn: (value: T, index: i32, self: TArray) => T,\r\n): TArray {\r\n  var length = array.length;\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  var result = instantiate<TArray>(length);\r\n  var resultBuffer = result.buffer;\r\n  for (let i = 0; i < length; i++) {\r\n    STORE<T, native<T>>(resultBuffer, i, <native<T>>callbackfn(LOAD<T>(buffer, i, byteOffset), i, array));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n@inline\r\nexport function FIND_INDEX<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\r\n): i32 {\r\n  var length = array.length;\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  for (let i = 0; i < length; i++) {\r\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\n@inline\r\nexport function SOME<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\r\n): bool {\r\n  var length = array.length;\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  for (let i = 0; i < length; i++) {\r\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n@inline\r\nexport function EVERY<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\r\n): bool {\r\n  var length = array.length;\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  for (let i = 0; i < length; i++) {\r\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\r\n      continue;\r\n    }\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n@inline\r\nexport function FOREACH<TArray extends TypedArray<T>, T>(\r\n  array: TArray,\r\n  callbackfn: (value: T, index: i32, array: TArray) => void,\r\n): void {\r\n  var length = array.length;\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n  for (let i = 0; i < length; i++) {\r\n    callbackfn(LOAD<T>(buffer, i, byteOffset), i, array);\r\n  }\r\n}\r\n\r\n@inline\r\nexport function REVERSE<TArray extends TypedArray<T>, T>(array: TArray): TArray {\r\n  var buffer = array.buffer;\r\n  var byteOffset = array.byteOffset;\r\n\r\n  for (let front = 0, back = array.length - 1; front < back; ++front, --back) {\r\n    let temp = LOAD<T>(buffer, front, byteOffset);\r\n    STORE<T>(buffer, front, LOAD<T>(buffer, back, byteOffset), byteOffset);\r\n    STORE<T>(buffer, back, temp, byteOffset);\r\n  }\r\n  return array;\r\n}\r\n","import { memcmp, memmove, memset } from \"./internal/memory\";\r\n\r\n@builtin export declare const HEAP_BASE: usize; // tslint:disable-line\r\n\r\n/* tslint:disable */\r\n\r\nexport namespace memory {\r\n\r\n  @builtin export declare function size(): i32;\r\n\r\n  @builtin export declare function grow(pages: i32): i32;\r\n\r\n  @builtin @inline\r\n  export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n    memset(dest, c, n); // fallback if \"bulk-memory\" isn't enabled\r\n  }\r\n\r\n  @builtin @inline\r\n  export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n    memmove(dest, src, n); // fallback if \"bulk-memory\" isn't enabled\r\n  }\r\n\r\n  @inline export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\r\n    return memcmp(vl, vr, n);\r\n  }\r\n\r\n  // Passive segments\r\n\r\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\r\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\r\n  // }\r\n\r\n  // export function drop(segmentIndex: u32): void {\r\n  //   __memory_drop(segmentIndex);\r\n  // }\r\n\r\n  // Allocator\r\n\r\n  @inline export function allocate(size: usize): usize {\r\n    if (isDefined(__memory_allocate)) return __memory_allocate(size);\r\n    WARNING(\"Calling 'memory.allocate' requires a memory manager to be present.\");\r\n    return <usize>unreachable();\r\n  }\r\n\r\n  @inline export function free(ptr: usize): void {\r\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; }\r\n    WARNING(\"Calling 'memory.free' requires a memory manager to be present.\");\r\n    unreachable();\r\n  }\r\n\r\n  @inline export function reset(): void {\r\n    if (isDefined(__memory_reset)) { __memory_reset(); return; }\r\n    unreachable();\r\n  }\r\n}\r\n","/**\r\n * Arena Memory Allocator\r\n *\r\n * Provides a `memory.reset` function to reset the heap to its initial state. A user has to make\r\n * sure that there are no more references to cleared memory afterwards. Always aligns to 8 bytes.\r\n *\r\n * @module std/assembly/allocator/arena\r\n *//***/\r\n\r\nimport { AL_MASK, MAX_SIZE_32 } from \"../internal/allocator\";\r\n\r\nvar startOffset: usize = (HEAP_BASE + AL_MASK) & ~AL_MASK;\r\nvar offset: usize = startOffset;\r\n\r\n// Memory allocator interface\r\n\r\n@global export function __memory_allocate(size: usize): usize {\r\n  if (size > MAX_SIZE_32) unreachable();\r\n  var ptr = offset;\r\n  var newPtr = (ptr + max<usize>(size, 1) + AL_MASK) & ~AL_MASK;\r\n  var pagesBefore = memory.size();\r\n  if (newPtr > <usize>pagesBefore << 16) {\r\n    let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\r\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\r\n    if (memory.grow(pagesWanted) < 0) {\r\n      if (memory.grow(pagesNeeded) < 0) {\r\n        unreachable(); // out of memory\r\n      }\r\n    }\r\n  }\r\n  offset = newPtr;\r\n  return ptr;\r\n}\r\n\r\n@global export function __memory_free(ptr: usize): void { /* nop */ }\r\n\r\n@global export function __memory_reset(): void {\r\n  offset = startOffset;\r\n}\r\n","// this function will go away once `memory.copy` becomes an intrinsic\r\nexport function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\r\n  var w: u32, x: u32;\r\n\r\n  // copy 1 byte each until src is aligned to 4 bytes\r\n  while (n && (src & 3)) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    n--;\r\n  }\r\n\r\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\r\n  if ((dest & 3) == 0) {\r\n    while (n >= 16) {\r\n      store<u32>(dest     , load<u32>(src     ));\r\n      store<u32>(dest +  4, load<u32>(src +  4));\r\n      store<u32>(dest +  8, load<u32>(src +  8));\r\n      store<u32>(dest + 12, load<u32>(src + 12));\r\n      src += 16; dest += 16; n -= 16;\r\n    }\r\n    if (n & 8) {\r\n      store<u32>(dest    , load<u32>(src    ));\r\n      store<u32>(dest + 4, load<u32>(src + 4));\r\n      dest += 8; src += 8;\r\n    }\r\n    if (n & 4) {\r\n      store<u32>(dest, load<u32>(src));\r\n      dest += 4; src += 4;\r\n    }\r\n    if (n & 2) { // drop to 2 bytes each\r\n      store<u16>(dest, load<u16>(src));\r\n      dest += 2; src += 2;\r\n    }\r\n    if (n & 1) { // drop to 1 byte\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    return;\r\n  }\r\n\r\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\r\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\r\n  if (n >= 32) {\r\n    switch (dest & 3) {\r\n      // known to be != 0\r\n      case 1: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 3;\r\n        while (n >= 17) {\r\n          x = load<u32>(src + 1);\r\n          store<u32>(dest, w >> 24 | x << 8);\r\n          w = load<u32>(src + 5);\r\n          store<u32>(dest + 4, x >> 24 | w << 8);\r\n          x = load<u32>(src + 9);\r\n          store<u32>(dest + 8, w >> 24 | x << 8);\r\n          w = load<u32>(src + 13);\r\n          store<u32>(dest + 12, x >> 24 | w << 8);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 2: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 2;\r\n        while (n >= 18) {\r\n          x = load<u32>(src + 2);\r\n          store<u32>(dest, w >> 16 | x << 16);\r\n          w = load<u32>(src + 6);\r\n          store<u32>(dest + 4, x >> 16 | w << 16);\r\n          x = load<u32>(src + 10);\r\n          store<u32>(dest + 8, w >> 16 | x << 16);\r\n          w = load<u32>(src + 14);\r\n          store<u32>(dest + 12, x >> 16 | w << 16);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 3: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 1;\r\n        while (n >= 19) {\r\n          x = load<u32>(src + 3);\r\n          store<u32>(dest, w >> 8 | x << 24);\r\n          w = load<u32>(src + 7);\r\n          store<u32>(dest + 4, x >> 8 | w << 24);\r\n          x = load<u32>(src + 11);\r\n          store<u32>(dest + 8, w >> 8 | x << 24);\r\n          w = load<u32>(src + 15);\r\n          store<u32>(dest + 12, x >> 8 | w << 24);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // copy remaining bytes one by one\r\n  if (n & 16) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 8) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 4) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 2) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 1) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n}\r\n\r\n// this function will go away once `memory.copy` becomes an intrinsic\r\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n  if (dest === src) return;\r\n  if (src + n <= dest || dest + n <= src) {\r\n    memcpy(dest, src, n);\r\n    return;\r\n  }\r\n  if (dest < src) {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while (dest & 7) {\r\n        if (!n) return;\r\n        --n;\r\n        store<u8>(dest++, load<u8>(src++));\r\n      }\r\n      while (n >= 8) {\r\n        store<u64>(dest, load<u64>(src));\r\n        n    -= 8;\r\n        dest += 8;\r\n        src  += 8;\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      --n;\r\n    }\r\n  } else {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while ((dest + n) & 7) {\r\n        if (!n) return;\r\n        store<u8>(dest + --n, load<u8>(src + n));\r\n      }\r\n      while (n >= 8) {\r\n        n -= 8;\r\n        store<u64>(dest + n, load<u64>(src + n));\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest + --n, load<u8>(src + n));\r\n    }\r\n  }\r\n}\r\n\r\n// this function will go away once `memory.fill` becomes an intrinsic\r\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n\r\n  // fill head and tail with minimal branching\r\n  if (!n) return;\r\n  store<u8>(dest, c);\r\n  store<u8>(dest + n - 1, c);\r\n  if (n <= 2) return;\r\n\r\n  store<u8>(dest + 1, c);\r\n  store<u8>(dest + 2, c);\r\n  store<u8>(dest + n - 2, c);\r\n  store<u8>(dest + n - 3, c);\r\n  if (n <= 6) return;\r\n  store<u8>(dest + 3, c);\r\n  store<u8>(dest + n - 4, c);\r\n  if (n <= 8) return;\r\n\r\n  // advance pointer to align it at 4-byte boundary\r\n  var k: usize = -dest & 3;\r\n  dest += k;\r\n  n -= k;\r\n  n &= -4;\r\n\r\n  var c32: u32 = <u32>-1 / 255 * c;\r\n\r\n  // fill head/tail up to 28 bytes each in preparation\r\n  store<u32>(dest, c32);\r\n  store<u32>(dest + n - 4, c32);\r\n  if (n <= 8) return;\r\n  store<u32>(dest + 4, c32);\r\n  store<u32>(dest + 8, c32);\r\n  store<u32>(dest + n - 12, c32);\r\n  store<u32>(dest + n - 8, c32);\r\n  if (n <= 24) return;\r\n  store<u32>(dest + 12, c32);\r\n  store<u32>(dest + 16, c32);\r\n  store<u32>(dest + 20, c32);\r\n  store<u32>(dest + 24, c32);\r\n  store<u32>(dest + n - 28, c32);\r\n  store<u32>(dest + n - 24, c32);\r\n  store<u32>(dest + n - 20, c32);\r\n  store<u32>(dest + n - 16, c32);\r\n\r\n  // align to a multiple of 8\r\n  k = 24 + (dest & 4);\r\n  dest += k;\r\n  n -= k;\r\n\r\n  // copy 32 bytes each\r\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\r\n  while (n >= 32) {\r\n    store<u64>(dest, c64);\r\n    store<u64>(dest + 8, c64);\r\n    store<u64>(dest + 16, c64);\r\n    store<u64>(dest + 24, c64);\r\n    n -= 32;\r\n    dest += 32;\r\n  }\r\n}\r\n\r\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\r\n  if (vl == vr) return 0;\r\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\r\n    n--; vl++; vr++;\r\n  }\r\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\r\n}\r\n","import {\r\n  HEADER_SIZE as HEADER_SIZE_AB\r\n} from \"./internal/arraybuffer\";\r\n\r\nimport {\r\n  HASH\r\n} from \"./internal/hash\";\r\n\r\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\r\n\r\n@inline const INITIAL_CAPACITY = 4;\r\n@inline const FILL_FACTOR: f64 = 8 / 3;\r\n@inline const FREE_FACTOR: f64 = 3 / 4;\r\n\r\n/** Structure of a map entry. */\r\n@unmanaged class MapEntry<K,V> {\r\n  key: K;\r\n  value: V;\r\n  taggedNext: usize; // LSB=1 indicates EMPTY\r\n}\r\n\r\n/** Empty bit. */\r\n@inline const EMPTY: usize = 1 << 0;\r\n\r\n/** Size of a bucket. */\r\n@inline const BUCKET_SIZE = sizeof<usize>();\r\n\r\n/** Computes the alignment of an entry. */\r\n@inline function ENTRY_ALIGN<K,V>(): usize {\r\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\r\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\r\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\r\n  return align;\r\n}\r\n\r\n/** Computes the aligned size of an entry. */\r\n@inline function ENTRY_SIZE<K,V>(): usize {\r\n  const align = ENTRY_ALIGN<K,V>();\r\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\r\n  return size;\r\n}\r\n\r\nexport class Map<K,V> {\r\n\r\n  // buckets holding references to the respective first entry within\r\n  private buckets: ArrayBuffer; // usize[bucketsMask + 1]\r\n  private bucketsMask: u32;\r\n\r\n  // entries in insertion order\r\n  private entries: ArrayBuffer; // MapEntry<K,V>[entriesCapacity]\r\n  private entriesCapacity: i32;\r\n  private entriesOffset: i32;\r\n  private entriesCount: i32;\r\n\r\n  get size(): i32 { return this.entriesCount; }\r\n\r\n  constructor() { this.clear(); }\r\n\r\n  clear(): void {\r\n    const bucketsSize = INITIAL_CAPACITY * <i32>BUCKET_SIZE;\r\n    this.buckets = new ArrayBuffer(bucketsSize);\r\n    this.bucketsMask = INITIAL_CAPACITY - 1;\r\n    const entriesSize = INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>();\r\n    this.entries = new ArrayBuffer(entriesSize, true);\r\n    this.entriesCapacity = INITIAL_CAPACITY;\r\n    this.entriesOffset = 0;\r\n    this.entriesCount = 0;\r\n  }\r\n\r\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\r\n    var entry = load<MapEntry<K,V>>(\r\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE,\r\n      HEADER_SIZE_AB\r\n    );\r\n    while (entry) {\r\n      if (!(entry.taggedNext & EMPTY) && entry.key == key) return entry;\r\n      entry = changetype<MapEntry<K,V>>(entry.taggedNext & ~EMPTY);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  has(key: K): bool {\r\n    return this.find(key, HASH<K>(key)) !== null;\r\n  }\r\n\r\n  get(key: K): V {\r\n    var entry = this.find(key, HASH<K>(key));\r\n    return entry ? entry.value : <V>unreachable();\r\n  }\r\n\r\n  set(key: K, value: V): void {\r\n    var hashCode = HASH<K>(key);\r\n    var entry = this.find(key, hashCode);\r\n    if (entry) {\r\n      entry.value = value;\r\n    } else {\r\n      // check if rehashing is necessary\r\n      if (this.entriesOffset == this.entriesCapacity) {\r\n        this.rehash(\r\n          this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\r\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\r\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\r\n        );\r\n      }\r\n      // append new entry\r\n      let entries = this.entries;\r\n      entry = changetype<MapEntry<K,V>>(\r\n        changetype<usize>(entries) + HEADER_SIZE_AB + this.entriesOffset++ * ENTRY_SIZE<K,V>()\r\n      );\r\n      entry.key = key;\r\n      entry.value = value;\r\n      ++this.entriesCount;\r\n      // link with previous entry in bucket\r\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\r\n      entry.taggedNext = load<usize>(bucketPtrBase, HEADER_SIZE_AB);\r\n      store<usize>(bucketPtrBase, changetype<usize>(entry), HEADER_SIZE_AB);\r\n      if (isManaged<K>()) __gc_link(changetype<usize>(this), changetype<usize>(key)); // tslint:disable-line\r\n      if (isManaged<V>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\r\n    }\r\n  }\r\n\r\n  delete(key: K): bool {\r\n    var entry = this.find(key, HASH<K>(key));\r\n    if (!entry) return false;\r\n    entry.taggedNext |= EMPTY;\r\n    --this.entriesCount;\r\n    // check if rehashing is appropriate\r\n    var halfBucketsMask = this.bucketsMask >> 1;\r\n    if (\r\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\r\n      this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\r\n    ) this.rehash(halfBucketsMask);\r\n    return true;\r\n  }\r\n\r\n  private rehash(newBucketsMask: u32): void {\r\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\r\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\r\n    var newEntriesCapacity = <i32>(newBucketsCapacity * FILL_FACTOR);\r\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>(), true);\r\n\r\n    // copy old entries to new entries\r\n    var oldPtr = changetype<usize>(this.entries) + HEADER_SIZE_AB;\r\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\r\n    var newPtr = changetype<usize>(newEntries) + HEADER_SIZE_AB;\r\n    while (oldPtr != oldEnd) {\r\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\r\n      if (!(oldEntry.taggedNext & EMPTY)) {\r\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\r\n        newEntry.key = oldEntry.key;\r\n        newEntry.value = oldEntry.value;\r\n        let newBucketIndex = HASH<K>(oldEntry.key) & newBucketsMask;\r\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\r\n        newEntry.taggedNext = load<usize>(newBucketPtrBase, HEADER_SIZE_AB);\r\n        store<usize>(newBucketPtrBase, newPtr, HEADER_SIZE_AB);\r\n        newPtr += ENTRY_SIZE<K,V>();\r\n      }\r\n      oldPtr += ENTRY_SIZE<K,V>();\r\n    }\r\n\r\n    this.buckets = newBuckets;\r\n    this.bucketsMask = newBucketsMask;\r\n    this.entries = newEntries;\r\n    this.entriesCapacity = newEntriesCapacity;\r\n    this.entriesOffset = this.entriesCount;\r\n  }\r\n\r\n  toString(): string {\r\n    return \"[object Map]\";\r\n  }\r\n\r\n  private __gc(): void {\r\n    __gc_mark(changetype<usize>(this.buckets)); // tslint:disable-line\r\n    var entries = this.entries;\r\n    __gc_mark(changetype<usize>(entries)); // tslint:disable-line\r\n    if (isManaged<K>() || isManaged<V>()) {\r\n      let offset: usize = 0;\r\n      let end: usize = this.entriesOffset * ENTRY_SIZE<K,V>();\r\n      while (offset < end) {\r\n        let entry = changetype<MapEntry<K,V>>(\r\n          changetype<usize>(entries) + HEADER_SIZE_AB + offset * ENTRY_SIZE<K,V>()\r\n        );\r\n        if (!(entry.taggedNext & EMPTY)) {\r\n          if (isManaged<K>()) __gc_mark(changetype<usize>(entry.key)); // tslint:disable-line\r\n          if (isManaged<V>()) __gc_mark(changetype<usize>(entry.value)); // tslint:disable-line\r\n        }\r\n        offset += ENTRY_SIZE<K,V>();\r\n      }\r\n    }\r\n  }\r\n}\r\n","import {\r\n  HEADER_SIZE\r\n} from \"./string\";\r\n\r\n/** Computes the 32-bit hash of a value of any type. */\r\n@inline\r\nexport function HASH<T>(key: T): u32 {\r\n  // branch-level tree-shaking makes this a `(return (call ...))`\r\n  if (isString(key)) {\r\n    return hashStr(key);\r\n  } else if (isReference<T>()) {\r\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\r\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\r\n  } else if (isFloat<T>()) {\r\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(key));\r\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(key));\r\n  } else {\r\n    if (sizeof<T>() == 1) return hash8 (<u32>key);\r\n    if (sizeof<T>() == 2) return hash16(<u32>key);\r\n    if (sizeof<T>() == 4) return hash32(<u32>key);\r\n    if (sizeof<T>() == 8) return hash64(<u64>key);\r\n  }\r\n  unreachable();\r\n}\r\n\r\n// FNV-1a 32-bit as a starting point, see: http://isthe.com/chongo/tech/comp/fnv/\r\n\r\n@inline const FNV_OFFSET: u32 = 2166136261;\r\n@inline const FNV_PRIME: u32 = 16777619;\r\n\r\nfunction hash8(key: u32): u32 {\r\n  return (FNV_OFFSET ^ key) * FNV_PRIME;\r\n}\r\n\r\nfunction hash16(key: u32): u32 {\r\n  var v = FNV_OFFSET;\r\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ( key >>  8        )) * FNV_PRIME;\r\n  return v;\r\n}\r\n\r\nfunction hash32(key: u32): u32 {\r\n  var v = FNV_OFFSET;\r\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((key >>  8) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((key >> 16) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ( key >> 24        )) * FNV_PRIME;\r\n  return v;\r\n}\r\n\r\nfunction hash64(key: u64): u32 {\r\n  var l = <u32> key;\r\n  var h = <u32>(key >>> 32);\r\n  var v = FNV_OFFSET;\r\n  v = (v ^ ( l        & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((l >>  8) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((l >> 16) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ( l >> 24        )) * FNV_PRIME;\r\n  v = (v ^ ( h        & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((h >>  8) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ((h >> 16) & 0xff)) * FNV_PRIME;\r\n  v = (v ^ ( h >> 24        )) * FNV_PRIME;\r\n  return v;\r\n}\r\n\r\nfunction hashStr(key: string): u32 {\r\n  var v = FNV_OFFSET;\r\n  for (let i: usize = 0, k: usize = key.length << 1; i < k; ++i) {\r\n    v = (v ^ <u32>load<u8>(changetype<usize>(key) + i, HEADER_SIZE)) * FNV_PRIME;\r\n  }\r\n  return v;\r\n}\r\n","import {\r\n  HEADER_SIZE,\r\n  MAX_BLENGTH,\r\n  allocateUnsafe\r\n} from \"./internal/arraybuffer\";\r\n\r\nimport {\r\n  Uint8ClampedArray,\r\n  Uint8Array,\r\n  Int8Array,\r\n  Uint16Array,\r\n  Int16Array,\r\n  Uint32Array,\r\n  Int32Array,\r\n  Uint64Array,\r\n  Int64Array\r\n} from \"./typedarray\";\r\n\r\nimport {\r\n  DataView\r\n} from \"./dataview\";\r\n\r\n@sealed\r\nexport class ArrayBuffer {\r\n\r\n  readonly byteLength: i32; // capped to [0, MAX_LENGTH]\r\n\r\n  @inline static isView<T>(value: T): bool {\r\n    if (value === null) return false;\r\n    if (value instanceof Uint8ClampedArray) return true;\r\n    if (value instanceof Uint8Array) return true;\r\n    if (value instanceof Int8Array) return true;\r\n    if (value instanceof Uint16Array) return true;\r\n    if (value instanceof Int16Array) return true;\r\n    if (value instanceof Uint32Array) return true;\r\n    if (value instanceof Int32Array) return true;\r\n    if (value instanceof Uint64Array) return true;\r\n    if (value instanceof Int64Array) return true;\r\n    if (value instanceof DataView) return true;\r\n    return false;\r\n  }\r\n\r\n  // @unsafe\r\n  @inline get data(): usize { return changetype<usize>(this) + HEADER_SIZE; }\r\n\r\n  constructor(length: i32, unsafe: bool = false) {\r\n    if (<u32>length > <u32>MAX_BLENGTH) throw new RangeError(\"Invalid array buffer length\");\r\n    var buffer = allocateUnsafe(length);\r\n    if (!unsafe) memory.fill(changetype<usize>(buffer) + HEADER_SIZE, 0, <usize>length);\r\n    return buffer;\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = MAX_BLENGTH): ArrayBuffer {\r\n    var len = this.byteLength;\r\n    begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\r\n    end = end < 0 ? max(len + end, 0) : min(end, len);\r\n    len = max(end - begin, 0);\r\n    var buffer = allocateUnsafe(len);\r\n    memory.copy(\r\n      changetype<usize>(buffer) + HEADER_SIZE,\r\n      changetype<usize>(this) + HEADER_SIZE + begin,\r\n      len\r\n    );\r\n    return buffer;\r\n  }\r\n\r\n  toString(): string {\r\n    return \"[object ArrayBuffer]\";\r\n  }\r\n}\r\n","import { CanvasRenderingContext2D } from \"../renderer/CanvasRenderingContext2D\";\r\n\r\nlet map = new Map<string, CanvasRenderingContext2D>();\r\n\r\n/**\r\n * This internal function is exported via the `./assembly/glue.ts` file. It receives an id from the\r\n * host, and a name. It's responsible for creating a new CanvasRenderingContext2D object, then\r\n * stores it on the map object by it's name. This allows developers to call `getContextById(name)`\r\n * to obtain the created reference to the canvas context.\r\n *\r\n * @param {string} name - The name of the CanvasRenderingContext2D object\r\n * @param {i32} id - The unique objectid created by the browser that identifies the context.\r\n */\r\nexport function __use_context(name: string, id: i32): void {\r\n  var result = new CanvasRenderingContext2D();\r\n  store<i32>(changetype<usize>(result) + offsetof<CanvasRenderingContext2D>(\"id\"), id);\r\n  map.set(name, result);\r\n}\r\n\r\n/**\r\n * This function is the only way to obtain a named canvas provided by the JavaScript host.\r\n *\r\n * @param {string} name - This is the name of the provided context.\r\n */\r\nexport function getContextById(name: string): CanvasRenderingContext2D {\r\n  if (!map.has(name)) throw new Error(\"Cannot find context with name: \" + name);\r\n  return map.get(name);\r\n}\r\n","\r\nimport { STORE } from \"internal/arraybuffer\";\r\n\r\n/**\r\n * The Buffer class is an ArrayBuffer backed data writer that utilizes the internal STORE function\r\n * provided by AssemblyScript to write data as fast as possible to memory. The generic type\r\n * parameter represents an enum indicating the instruction type values coupled with the memory\r\n * writes. Each instruction write results in the following values written to the buffer:\r\n *\r\n * 1. [instruction] `T` - This value is the instruction type cast to a `f64`\r\n * 2. [nextIndex] `i32` - This value is the pointer to the next instruction index\r\n * 3. [...args] `f64[]` - These values are the argument values for the instruction\r\n */\r\nexport class Buffer<T extends i32> {\r\n  /**\r\n   * The buffer property is a reference to an allocated block of memory that contains all the\r\n   * currently written values to the buffer. The browser eventually should obtain a pointer to this\r\n   * block and read the values from it to perform actions.\r\n   */\r\n  protected _buffer: ArrayBuffer = new ArrayBuffer(0x10000 * sizeof<f64>(), true);\r\n\r\n  /**\r\n   * The offset property is a pointer to the next index that will receive a written value.\r\n   */\r\n  private _offset: i32 = 0;\r\n\r\n  /**\r\n   * Write a single instruction to the buffer without any parameters. This results in two values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeZero(inst: T): void {\r\n    var buff: ArrayBuffer = this._buffer;\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 2;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Write a single instruction to the buffer with a single parameter. This results in three values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeOne(inst: T, a: f64): void {\r\n    var buff: ArrayBuffer = this._buffer;\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 3;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Write a single instruction to the buffer with two parameters. This results in four values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\r\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeTwo(inst: T, a: f64, b: f64): void {\r\n    var buff: ArrayBuffer = this._buffer;\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 4;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    STORE<f64>(buff, index + 3, b);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Write a single instruction to the buffer with three parameters. This results in five values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\r\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\r\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeThree(inst: T, a: f64, b: f64, c: f64): void {\r\n    var buff: ArrayBuffer = this._buffer;\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 5;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    STORE<f64>(buff, index + 3, b);\r\n    STORE<f64>(buff, index + 4, c);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Write a single instruction to the buffer with four parameters. This results in six values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\r\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\r\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\r\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeFour(inst: T, a: f64, b: f64, c: f64, d: f64): void {\r\n    var buff: ArrayBuffer = this._buffer;\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 6;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    STORE<f64>(buff, index + 3, b);\r\n    STORE<f64>(buff, index + 4, c);\r\n    STORE<f64>(buff, index + 5, d);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Write a single instruction to the buffer with five parameters. This results in seven values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\r\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\r\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\r\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} d - The fifth parameter for the instruction to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeFive(inst: T, a: f64, b: f64, c: f64, d: f64, e: f64): void {\r\n    var buff: ArrayBuffer = this._buffer;\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 7;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    STORE<f64>(buff, index + 3, b);\r\n    STORE<f64>(buff, index + 4, c);\r\n    STORE<f64>(buff, index + 5, d);\r\n    STORE<f64>(buff, index + 6, e);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Write a single instruction to the buffer with six parameters. This results in eight values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\r\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\r\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\r\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} e - The fifth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} f - The sixth parameter for the instruction to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeSix(inst: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n    var buff: ArrayBuffer = this._buffer;\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 8;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    STORE<f64>(buff, index + 3, b);\r\n    STORE<f64>(buff, index + 4, c);\r\n    STORE<f64>(buff, index + 5, d);\r\n    STORE<f64>(buff, index + 6, e);\r\n    STORE<f64>(buff, index + 7, f);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Write a single instruction to the buffer with eight parameters. This results in ten values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\r\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\r\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\r\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} e - The fifth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} f - The sixth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} g - The seventh parameter for the instruction to be written to the buffer.\r\n   * @param {f64} h - The eighth parameter for the instruction to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeEight(inst: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64, g: f64, h: f64): void {\r\n    var buff: ArrayBuffer = this._buffer;\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 10;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    STORE<f64>(buff, index + 3, b);\r\n    STORE<f64>(buff, index + 4, c);\r\n    STORE<f64>(buff, index + 5, d);\r\n    STORE<f64>(buff, index + 6, e);\r\n    STORE<f64>(buff, index + 7, f);\r\n    STORE<f64>(buff, index + 8, g);\r\n    STORE<f64>(buff, index + 9, h);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Write a single instruction to the buffer with nine parameters. This results in eleven values\r\n   * written to the buffer.\r\n   *\r\n   * @param {T} inst - The instruction type to be written to the buffer.\r\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\r\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\r\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\r\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} e - The fifth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} f - The sixth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} g - The seventh parameter for the instruction to be written to the buffer.\r\n   * @param {f64} h - The eighth parameter for the instruction to be written to the buffer.\r\n   * @param {f64} i - The ninth parameter for the instruction to be written to the buffer.\r\n   */\r\n  @inline\r\n  protected _writeNine(inst: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64, g: f64, h: f64, i: f64): void {\r\n    var buff: ArrayBuffer = this._buffer;\r\n    var index: i32 = this._offset;\r\n    var next: i32 = index + 11;\r\n    STORE<f64>(buff, index, <f64>inst);\r\n    STORE<f64>(buff, index + 1, <f64>next);\r\n    STORE<f64>(buff, index + 2, a);\r\n    STORE<f64>(buff, index + 3, b);\r\n    STORE<f64>(buff, index + 4, c);\r\n    STORE<f64>(buff, index + 5, d);\r\n    STORE<f64>(buff, index + 6, e);\r\n    STORE<f64>(buff, index + 7, f);\r\n    STORE<f64>(buff, index + 8, g);\r\n    STORE<f64>(buff, index + 9, h);\r\n    STORE<f64>(buff, index + 10, i);\r\n    this._offset = next;\r\n  }\r\n\r\n  /**\r\n   * Reset the buffer back to position 0.\r\n   */\r\n  @inline\r\n  protected _resetBuffer(): void {\r\n    this._offset = 0;\r\n  }\r\n}\r\n","import {\r\n  CharCode,\r\n  allocateUnsafe as allocateUnsafeString,\r\n  freeUnsafe as freeUnsafeString,\r\n  HEADER_SIZE as STRING_HEADER_SIZE\r\n} from \"./string\";\r\n\r\nimport {\r\n  LOAD\r\n} from \"./arraybuffer\";\r\n\r\n@inline export const MAX_DOUBLE_LENGTH = 28;\r\n\r\n@lazy @inline const POWERS10: u32[] = [\r\n  1,\r\n  10,\r\n  100,\r\n  1000,\r\n  10000,\r\n  100000,\r\n  1000000,\r\n  10000000,\r\n  100000000,\r\n  1000000000\r\n];\r\n\r\n/*\r\n  Lookup table for pairwise char codes in range [0-99]\r\n\r\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\r\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\r\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\r\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\r\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\r\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\r\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\r\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\r\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\r\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\r\n*/\r\n@lazy @inline const DIGITS: u32[] = [\r\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\r\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\r\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\r\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\r\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\r\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\r\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\r\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\r\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\r\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\r\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\r\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\r\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\r\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\r\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\r\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\r\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\r\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\r\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\r\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\r\n];\r\n\r\n@lazy @inline const EXP_POWERS: i16[] = [\r\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\r\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\r\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\r\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\r\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\r\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\r\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\r\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\r\n    907,   933,   960,   986,  1013,  1039,  1066\r\n];\r\n\r\n// 1e-348, 1e-340, ..., 1e340\r\n@lazy @inline const FRC_POWERS: u64[] = [\r\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\r\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\r\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\r\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\r\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\r\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\r\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\r\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\r\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\r\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\r\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\r\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\r\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\r\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\r\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\r\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\r\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\r\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\r\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\r\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\r\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\r\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\r\n];\r\n\r\n// Count number of decimals for u32 values\r\n// In our case input value always non-zero so we can simplify some parts\r\nexport function decimalCount32(value: u32): u32 {\r\n  if (ASC_SHRINK_LEVEL >= 1) {\r\n    let l: u32 = 32 - clz<u32>(value); // log2\r\n    let t = l * 1233 >>> 12; // log10\r\n\r\n    let lutbuf = <ArrayBuffer>POWERS10.buffer_;\r\n    let power  = LOAD<u32>(lutbuf, t);\r\n    t -= <u32>(value < power);\r\n    return t + 1;\r\n  } else {\r\n    if (value < 100000) {\r\n      if (value < 100) {\r\n        return select<u32>(1, 2, value < 10);\r\n      } else {\r\n        let m = select<u32>(4, 5, value < 10000);\r\n        return select<u32>(3, m, value < 1000);\r\n      }\r\n    } else {\r\n      if (value < 10000000) {\r\n        return select<u32>(6, 7, value < 1000000);\r\n      } else {\r\n        let m = select<u32>(9, 10, value < 1000000000);\r\n        return select<u32>(8, m, value < 100000000);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Count number of decimals for u64 values\r\n// In our case input value always greater than 2^32-1 so we can skip some parts\r\nexport function decimalCount64(value: u64): u32 {\r\n  if (ASC_SHRINK_LEVEL >= 1) {\r\n    let l: u32 = 64 - <u32>clz<u64>(value); // log2\r\n    let t = l * 1233 >>> 12; // log10\r\n\r\n    let lutbuf = <ArrayBuffer>POWERS10.buffer_;\r\n    let power  = LOAD<u32,u64>(lutbuf, t - 10);\r\n    t -= <u32>(value < 10000000000 * power);\r\n    return t + 1;\r\n  } else {\r\n    if (value < 1000000000000000) {\r\n      if (value < 1000000000000) {\r\n        return select<u32>(11, 12, value < 100000000000);\r\n      } else {\r\n        let m = select<u32>(14, 15, value < 100000000000000);\r\n        return select<u32>(13, m, value < 10000000000000);\r\n      }\r\n    } else {\r\n      if (value < 100000000000000000) {\r\n        return select<u32>(16, 17, value < 10000000000000000);\r\n      } else {\r\n        let m = select<u32>(19, 20, value < 10000000000000000000);\r\n        return select<u32>(18, m, value < 1000000000000000000);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction utoa32_lut(buffer: usize, num: u32, offset: usize): void {\r\n  var lutbuf = <ArrayBuffer>DIGITS.buffer_;\r\n\r\n  while (num >= 10000) {\r\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\r\n    let t = num / 10000;\r\n    let r = num % 10000;\r\n    num = t;\r\n\r\n    let d1 = r / 100;\r\n    let d2 = r % 100;\r\n\r\n    let digits1 = LOAD<u32,u64>(lutbuf, d1);\r\n    let digits2 = LOAD<u32,u64>(lutbuf, d2);\r\n\r\n    offset -= 4;\r\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\r\n  }\r\n\r\n  if (num >= 100) {\r\n    let t  = num / 100;\r\n    let d1 = num % 100;\r\n    num = t;\r\n    offset -= 2;\r\n    let digits = LOAD<u32>(lutbuf, d1);\r\n    store<u32>(buffer + (offset << 1), digits, STRING_HEADER_SIZE);\r\n  }\r\n\r\n  if (num >= 10) {\r\n    offset -= 2;\r\n    let digits = LOAD<u32>(lutbuf, num);\r\n    store<u32>(buffer + (offset << 1), digits, STRING_HEADER_SIZE);\r\n  } else {\r\n    offset -= 1;\r\n    let digit = CharCode._0 + num;\r\n    store<u16>(buffer + (offset << 1), digit, STRING_HEADER_SIZE);\r\n  }\r\n}\r\n\r\nfunction utoa64_lut(buffer: usize, num: u64, offset: usize): void {\r\n  var lutbuf = <ArrayBuffer>DIGITS.buffer_;\r\n\r\n  while (num >= 100000000) {\r\n    let t = num / 100000000;\r\n    let r = <usize>(num - t * 100000000);\r\n    num = t;\r\n\r\n    let b = r / 10000;\r\n    let c = r % 10000;\r\n\r\n    let b1 = b / 100;\r\n    let b2 = b % 100;\r\n    let c1 = c / 100;\r\n    let c2 = c % 100;\r\n\r\n    let digits1 = LOAD<u32,u64>(lutbuf, c1);\r\n    let digits2 = LOAD<u32,u64>(lutbuf, c2);\r\n\r\n    offset -= 4;\r\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\r\n\r\n    digits1 = LOAD<u32,u64>(lutbuf, b1);\r\n    digits2 = LOAD<u32,u64>(lutbuf, b2);\r\n\r\n    offset -= 4;\r\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\r\n  }\r\n\r\n  utoa32_lut(buffer, <u32>num, offset);\r\n}\r\n\r\nfunction utoa_simple<T>(buffer: usize, num: T, offset: usize): void {\r\n  do {\r\n    let t = num / 10;\r\n    let r = <u32>(num % 10);\r\n    num = t;\r\n    offset -= 1;\r\n    store<u16>(buffer + (offset << 1), CharCode._0 + r, STRING_HEADER_SIZE);\r\n  } while (num);\r\n}\r\n\r\n@inline\r\nexport function utoa32_core(buffer: usize, num: u32, offset: u32): void {\r\n  if (ASC_SHRINK_LEVEL >= 1) {\r\n    utoa_simple(buffer, num, offset);\r\n  } else {\r\n    utoa32_lut(buffer, num, offset);\r\n  }\r\n}\r\n\r\n@inline\r\nexport function utoa64_core(buffer: usize, num: u64, offset: u32): void {\r\n  if (ASC_SHRINK_LEVEL >= 1) {\r\n    utoa_simple(buffer, num, offset);\r\n  } else {\r\n    utoa64_lut(buffer, num, offset);\r\n  }\r\n}\r\n\r\nexport function utoa32(value: u32): String {\r\n  if (!value) return \"0\";\r\n\r\n  var decimals = decimalCount32(value);\r\n  var buffer   = allocateUnsafeString(decimals);\r\n\r\n  utoa32_core(changetype<usize>(buffer), value, decimals);\r\n  return buffer;\r\n}\r\n\r\nexport function itoa32(value: i32): String {\r\n  if (!value) return \"0\";\r\n\r\n  var sign = value < 0;\r\n  if (sign) value = -value;\r\n\r\n  var decimals = decimalCount32(value) + <u32>sign;\r\n  var buffer   = allocateUnsafeString(decimals);\r\n\r\n  utoa32_core(changetype<usize>(buffer), value, decimals);\r\n  if (sign) store<u16>(changetype<usize>(buffer), CharCode.MINUS, STRING_HEADER_SIZE);\r\n\r\n  return buffer;\r\n}\r\n\r\nexport function utoa64(value: u64): String {\r\n  if (!value) return \"0\";\r\n\r\n  var buffer: String;\r\n  if (value <= u32.MAX_VALUE) {\r\n    let val32    = <u32>value;\r\n    let decimals = decimalCount32(val32);\r\n    buffer = allocateUnsafeString(decimals);\r\n    utoa32_core(changetype<usize>(buffer), val32, decimals);\r\n  } else {\r\n    let decimals = decimalCount64(value);\r\n    buffer = allocateUnsafeString(decimals);\r\n    utoa64_core(changetype<usize>(buffer), value, decimals);\r\n  }\r\n  return buffer;\r\n}\r\n\r\nexport function itoa64(value: i64): String {\r\n  if (!value) return \"0\";\r\n\r\n  var sign = value < 0;\r\n  if (sign) value = -value;\r\n\r\n  var buffer: String;\r\n  if (<u64>value <= <u64>u32.MAX_VALUE) {\r\n    let val32    = <u32>value;\r\n    let decimals = decimalCount32(val32) + <u32>sign;\r\n    buffer = allocateUnsafeString(decimals);\r\n    utoa32_core(changetype<usize>(buffer), val32, decimals);\r\n  } else {\r\n    let decimals = decimalCount64(value) + <u32>sign;\r\n    buffer = allocateUnsafeString(decimals);\r\n    utoa64_core(changetype<usize>(buffer), value, decimals);\r\n  }\r\n  if (sign) store<u16>(changetype<usize>(buffer), CharCode.MINUS, STRING_HEADER_SIZE);\r\n\r\n  return buffer;\r\n}\r\n\r\nexport function itoa<T>(value: T): String {\r\n  if (!isInteger<T>()) {\r\n    assert(false); // unexpecteble non-integer generic type\r\n  } else {\r\n    if (isSigned<T>()) {\r\n      if (sizeof<T>() <= 4) {\r\n        return itoa32(<i32>value);\r\n      } else {\r\n        return itoa64(<i64>value);\r\n      }\r\n    } else {\r\n      if (sizeof<T>() <= 4) {\r\n        return utoa32(<u32>value);\r\n      } else {\r\n        return utoa64(<u64>value);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n@lazy var _K: i32 = 0;\r\n// @lazy var _frc: u64 = 0;\r\n@lazy var _exp: i32 = 0;\r\n@lazy var _frc_minus: u64 = 0;\r\n@lazy var _frc_plus:  u64 = 0;\r\n@lazy var _frc_pow: u64 = 0;\r\n@lazy var _exp_pow: i32 = 0;\r\n\r\n@inline\r\nfunction umul64f(u: u64, v: u64): u64 {\r\n  var u0 = u & 0xFFFFFFFF;\r\n  var v0 = v & 0xFFFFFFFF;\r\n\r\n  var u1 = u >> 32;\r\n  var v1 = v >> 32;\r\n\r\n  var l = u0 * v0;\r\n  var t = u1 * v0 + (l >> 32);\r\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\r\n\r\n  w += 0x7FFFFFFF; // rounding\r\n\r\n  t >>= 32;\r\n  w >>= 32;\r\n\r\n  return u1 * v1 + t + w;\r\n}\r\n\r\n@inline\r\nfunction umul64e(e1: i32, e2: i32): i32 {\r\n  return e1 + e2 + 64; // where 64 is significand size\r\n}\r\n\r\n@inline\r\nfunction normalizedBoundaries(f: u64, e: i32): void {\r\n  var frc = (f << 1) + 1;\r\n  var exp = e - 1;\r\n  var off = <i32>clz<u64>(frc);\r\n  frc <<= off;\r\n  exp  -= off;\r\n\r\n  var m = 1 + <i32>(f == 0x0010000000000000);\r\n\r\n  _frc_plus  = frc;\r\n  _frc_minus = ((f << m) - 1) << e - m - exp;\r\n  _exp = exp;\r\n}\r\n\r\n@inline\r\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\r\n  var lastp = buffer + ((len - 1) << 1);\r\n  var digit = load<u16>(lastp, STRING_HEADER_SIZE);\r\n  while (\r\n    rest < wp_w &&\r\n    delta - rest >= ten_kappa && (\r\n      rest + ten_kappa < wp_w ||\r\n      wp_w - rest > rest + ten_kappa - wp_w\r\n    )\r\n  ) {\r\n    --digit;\r\n    rest += ten_kappa;\r\n  }\r\n  store<u16>(lastp, digit, STRING_HEADER_SIZE);\r\n}\r\n\r\n@inline\r\nfunction getCachedPower(minExp: i32): void {\r\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\r\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\r\n  var k = <i32>dk;\r\n      k += <i32>(k != dk); // conversion with ceil\r\n\r\n  var index = (k >> 3) + 1;\r\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\r\n  var frcPowers = <ArrayBuffer>FRC_POWERS.buffer_;\r\n  var expPowers = <ArrayBuffer>EXP_POWERS.buffer_;\r\n  _frc_pow = LOAD<u64>(frcPowers, index);\r\n  _exp_pow = LOAD<i16,i32>(expPowers, index);\r\n}\r\n\r\n@inline\r\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\r\n\r\n  // frexp routine\r\n  var uv  = reinterpret<u64>(value);\r\n  var exp = <i32>((uv & 0x7FF0000000000000) >>> 52);\r\n  var sid = uv & 0x000FFFFFFFFFFFFF;\r\n  var frc = (<u64>(exp != 0) << 52) + sid;\r\n      exp = select<i32>(exp, 1, exp != 0) - (0x3FF + 52);\r\n\r\n  normalizedBoundaries(frc, exp);\r\n  getCachedPower(_exp);\r\n\r\n  // normalize\r\n  var off = <i32>clz<u64>(frc);\r\n  frc <<= off;\r\n  exp  -= off;\r\n\r\n  var frc_pow = _frc_pow;\r\n  var exp_pow = _exp_pow;\r\n\r\n  var w_frc = umul64f(frc, frc_pow);\r\n  var w_exp = umul64e(exp, exp_pow);\r\n\r\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\r\n  var wp_exp = umul64e(_exp,      exp_pow);\r\n\r\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\r\n  var delta  = wp_frc - wm_frc;\r\n\r\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\r\n}\r\n\r\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\r\n  var one_exp = -mp_exp;\r\n  var one_frc = (<u64>1) << one_exp;\r\n  var mask    = one_frc - 1;\r\n\r\n  var wp_w_frc = mp_frc - w_frc;\r\n  var wp_w_exp = mp_exp;\r\n\r\n  var p1 = <u32>(mp_frc >> one_exp);\r\n  var p2 = mp_frc & mask;\r\n\r\n  var kappa = <i32>decimalCount32(p1);\r\n  var len = sign;\r\n\r\n  var powers10 = <ArrayBuffer>POWERS10.buffer_;\r\n\r\n  while (kappa > 0) {\r\n    let d: u32;\r\n    switch (kappa) {\r\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\r\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\r\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\r\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\r\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\r\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\r\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\r\n      case  3: { d = p1 /        100; p1 %=        100; break; }\r\n      case  2: { d = p1 /         10; p1 %=         10; break; }\r\n      case  1: { d = p1;              p1 =           0; break; }\r\n      default: { d = 0; break; }\r\n    }\r\n\r\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d, STRING_HEADER_SIZE);\r\n\r\n    --kappa;\r\n    let tmp = ((<u64>p1) << one_exp) + p2;\r\n    if (tmp <= delta) {\r\n      _K += kappa;\r\n      grisuRound(buffer, len, delta, tmp, LOAD<u32,u64>(powers10, kappa) << one_exp, wp_w_frc);\r\n      return len;\r\n    }\r\n  }\r\n\r\n  while (1) {\r\n    p2    *= 10;\r\n    delta *= 10;\r\n\r\n    let d = p2 >> one_exp;\r\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d, STRING_HEADER_SIZE);\r\n\r\n    p2 &= mask;\r\n    --kappa;\r\n    if (p2 < delta) {\r\n      _K += kappa;\r\n      wp_w_frc *= LOAD<u32,u64>(powers10, -kappa);\r\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\r\n      return len;\r\n    }\r\n  }\r\n\r\n  return len;\r\n}\r\n\r\n@inline\r\nfunction genExponent(buffer: usize, k: i32): i32 {\r\n  var sign = k < 0;\r\n  if (sign) k = -k;\r\n  var decimals = decimalCount32(k) + 1;\r\n  utoa32_core(buffer, k, decimals);\r\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign), STRING_HEADER_SIZE);\r\n  return decimals;\r\n}\r\n\r\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\r\n  if (!k) {\r\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16), STRING_HEADER_SIZE);\r\n    return length + 2;\r\n  }\r\n\r\n  var kk = length + k;\r\n  if (length <= kk && kk <= 21) {\r\n    // 1234e7 -> 12340000000\r\n    for (let i = length; i < kk; ++i) {\r\n      store<u16>(buffer + (i << 1), CharCode._0, STRING_HEADER_SIZE);\r\n    }\r\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16), STRING_HEADER_SIZE);\r\n    return kk + 2;\r\n  } else if (kk > 0 && kk <= 21) {\r\n    // 1234e-2 -> 12.34\r\n    let ptr = buffer + (kk << 1);\r\n    memory.copy(\r\n      ptr + STRING_HEADER_SIZE + 2,\r\n      ptr + STRING_HEADER_SIZE,\r\n      -k << 1\r\n    );\r\n    store<u16>(buffer + (kk << 1), CharCode.DOT, STRING_HEADER_SIZE);\r\n    return length + 1;\r\n  } else if (-6 < kk && kk <= 0) {\r\n    // 1234e-6 -> 0.001234\r\n    let offset = 2 - kk;\r\n    memory.copy(\r\n      buffer + STRING_HEADER_SIZE + (offset << 1),\r\n      buffer + STRING_HEADER_SIZE,\r\n      length << 1\r\n    );\r\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16), STRING_HEADER_SIZE);\r\n    for (let i = 2; i < offset; ++i) {\r\n      store<u16>(buffer + (i << 1), CharCode._0, STRING_HEADER_SIZE);\r\n    }\r\n    return length + offset;\r\n  } else if (length == 1) {\r\n    // 1e30\r\n    store<u16>(buffer, CharCode.e, STRING_HEADER_SIZE + 2);\r\n    length = genExponent(buffer + 4, kk - 1);\r\n    return length + 2;\r\n  } else {\r\n    let len = length << 1;\r\n    memory.copy(\r\n      buffer + STRING_HEADER_SIZE + 4,\r\n      buffer + STRING_HEADER_SIZE + 2,\r\n      len - 2\r\n    );\r\n    store<u16>(buffer,       CharCode.DOT, STRING_HEADER_SIZE + 2);\r\n    store<u16>(buffer + len, CharCode.e,   STRING_HEADER_SIZE + 2);\r\n    length += genExponent(buffer + len + 4, kk - 1);\r\n    return length + 2;\r\n  }\r\n}\r\n\r\nexport function dtoa_core(buffer: usize, value: f64): i32 {\r\n  var sign = <i32>(value < 0);\r\n  if (sign) {\r\n    value = -value;\r\n    store<u16>(buffer, CharCode.MINUS, STRING_HEADER_SIZE);\r\n  }\r\n  // assert(value > 0 && value <= 1.7976931348623157e308);\r\n  var len = grisu2(value, buffer, sign);\r\n      len = prettify(buffer + (sign << 1), len - sign, _K);\r\n  return len + sign;\r\n}\r\n\r\nexport function dtoa(value: f64): String {\r\n  if (value == 0) return \"0.0\";\r\n  if (!isFinite(value)) {\r\n    if (isNaN(value)) return \"NaN\";\r\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\r\n  }\r\n  var buffer = allocateUnsafeString(MAX_DOUBLE_LENGTH);\r\n  var length = dtoa_core(changetype<usize>(buffer), value);\r\n  var result = buffer.substring(0, length);\r\n  freeUnsafeString(buffer);\r\n  return result;\r\n}\r\n\r\nexport function itoa_stream<T>(buffer: usize, offset: usize, value: T): u32 {\r\n  buffer += (offset << 1);\r\n  if (!value) {\r\n    store<u16>(buffer, CharCode._0, STRING_HEADER_SIZE);\r\n    return 1;\r\n  }\r\n  var decimals: u32 = 0;\r\n  if (isSigned<T>()) {\r\n    let sign = value < 0;\r\n    if (sign) value = -value;\r\n    if (sizeof<T>() <= 4) {\r\n      decimals = decimalCount32(value) + <u32>sign;\r\n      utoa32_core(buffer, value, decimals);\r\n    } else {\r\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\r\n        let val32 = <u32>value;\r\n        decimals = decimalCount32(val32) + <u32>sign;\r\n        utoa32_core(buffer, val32, decimals);\r\n      } else {\r\n        decimals = decimalCount64(value) + <u32>sign;\r\n        utoa64_core(buffer, value, decimals);\r\n      }\r\n    }\r\n    if (sign) store<u16>(buffer, CharCode.MINUS, STRING_HEADER_SIZE);\r\n  } else {\r\n    if (sizeof<T>() <= 4) {\r\n      decimals = decimalCount32(value);\r\n      utoa32_core(buffer, value, decimals);\r\n    } else {\r\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\r\n        let val32 = <u32>value;\r\n        decimals = decimalCount32(val32);\r\n        utoa32_core(buffer, val32, decimals);\r\n      } else {\r\n        decimals = decimalCount64(value);\r\n        utoa64_core(buffer, value, decimals);\r\n      }\r\n    }\r\n  }\r\n  return decimals;\r\n}\r\n\r\nexport function dtoa_stream(buffer: usize, offset: usize, value: f64): u32 {\r\n  buffer += (offset << 1);\r\n  if (value == 0.0) {\r\n    store<u16>(buffer, CharCode._0,  STRING_HEADER_SIZE + 0);\r\n    store<u16>(buffer, CharCode.DOT, STRING_HEADER_SIZE + 2);\r\n    store<u16>(buffer, CharCode._0,  STRING_HEADER_SIZE + 4);\r\n    return 3;\r\n  }\r\n  if (!isFinite(value)) {\r\n    if (isNaN(value)) {\r\n      store<u16>(buffer, CharCode.N, STRING_HEADER_SIZE + 0);\r\n      store<u16>(buffer, CharCode.a, STRING_HEADER_SIZE + 2);\r\n      store<u16>(buffer, CharCode.N, STRING_HEADER_SIZE + 4);\r\n      return 3;\r\n    } else {\r\n      let sign = <i32>(value < 0);\r\n      let len  = 8 + sign;\r\n      let source = changetype<usize>(select<String>(\"-Infinity\", \"Infinity\", sign));\r\n      memory.copy(buffer + STRING_HEADER_SIZE, source + STRING_HEADER_SIZE, len << 1);\r\n      return len;\r\n    }\r\n  }\r\n  return dtoa_core(buffer, value);\r\n}\r\n","/* tslint:disable */\r\n\r\n@builtin @inline export const NaN: f64 = 0 / 0;\r\n@builtin @inline export const Infinity: f64 = 1 / 0;\r\n\r\n@builtin export declare function isInteger<T>(value?: T): bool;\r\n@builtin export declare function isFloat<T>(value?: T): bool;\r\n@builtin export declare function isSigned<T>(value?: T): bool;\r\n@builtin export declare function isReference<T>(value?: T): bool;\r\n@builtin export declare function isString<T>(value?: T): bool;\r\n@builtin export declare function isArray<T>(value?: T): bool;\r\n@builtin export declare function isArrayLike<T>(value?: T): bool;\r\n@builtin export declare function isFunction<T>(value?: T): bool;\r\n@builtin export declare function isNullable<T>(value?: T): bool;\r\n@builtin export declare function isDefined(expression: void): bool;\r\n@builtin export declare function isConstant(expression: void): bool;\r\n@builtin export declare function isManaged<T>(value?: T): bool;\r\n@inline export function isNaN<T>(value: T): bool { return value != value; }\r\n@inline export function isFinite<T>(value: T): bool { return value - value == 0; }\r\n\r\n@builtin export declare function clz<T>(value: T): T;\r\n@builtin export declare function ctz<T>(value: T): T;\r\n@builtin export declare function popcnt<T>(value: T): T;\r\n@builtin export declare function rotl<T>(value: T, shift: T): T;\r\n@builtin export declare function rotr<T>(value: T, shift: T): T;\r\n@builtin export declare function abs<T>(value: T): T;\r\n@builtin export declare function max<T>(left: T, right: T): T;\r\n@builtin export declare function min<T>(left: T, right: T): T;\r\n@builtin export declare function ceil<T>(value: T): T;\r\n@builtin export declare function floor<T>(value: T): T;\r\n@builtin export declare function copysign<T>(left: T, right: T): T;\r\n@builtin export declare function nearest<T>(value: T): T;\r\n@builtin export declare function reinterpret<T>(value: void): T;\r\n@builtin export declare function sqrt<T>(value: T): T;\r\n@builtin export declare function trunc<T>(value: T): T;\r\n@builtin export declare function load<T>(offset: usize, immOffset?: usize, immAlign?: usize): T;\r\n@builtin export declare function store<T>(offset: usize, value: void, immOffset?: usize, immAlign?: usize): void;\r\n@builtin export declare function sizeof<T>(): usize; // | u32 / u64\r\n@builtin export declare function alignof<T>(): usize; // | u32 / u64\r\n@builtin export declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\r\n@builtin export declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\r\n@builtin export declare function unreachable(): void;\r\n@builtin export declare function changetype<T>(value: void): T;\r\n@builtin export declare function assert<T>(isTrueish: T, message?: string): T;\r\n@builtin export declare function unchecked<T>(expr: T): T;\r\n@builtin export declare function call_indirect<T>(target: void, ...args: void[]): T;\r\n@builtin export declare function instantiate<T>(...args: void[]): T;\r\n\r\nexport namespace atomic {\r\n  @builtin export declare function load<T>(offset: usize, immOffset?: usize): T;\r\n  @builtin export declare function store<T>(offset: usize, value: T, immOffset?: usize): void;\r\n  @builtin export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\r\n  @builtin export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\r\n  @builtin export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\r\n  @builtin export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\r\n  @builtin export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\r\n  @builtin export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\r\n  @builtin export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\r\n  @builtin export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\r\n  @builtin export declare function notify(ptr: usize, count: i32): i32;\r\n}\r\n\r\n@lazy export const enum AtomicWaitResult {\r\n  OK = 0,\r\n  NOT_EQUAL = 1,\r\n  TIMED_OUT = 2\r\n}\r\n\r\n@builtin export declare function i8(value: void): i8;\r\nexport namespace i8 {\r\n  @lazy export const MIN_VALUE: i8 = -128;\r\n  @lazy export const MAX_VALUE: i8 =  127;\r\n}\r\n\r\n@builtin export declare function i16(value: void): i16;\r\nexport namespace i16 {\r\n  @lazy export const MIN_VALUE: i16 = -32768;\r\n  @lazy export const MAX_VALUE: i16 =  32767;\r\n}\r\n\r\n@builtin export declare function i32(value: void): i32;\r\nexport namespace i32 {\r\n  @lazy export const MIN_VALUE: i32 = -2147483648;\r\n  @lazy export const MAX_VALUE: i32 =  2147483647;\r\n  @builtin export declare function clz(value: i32): i32;\r\n  @builtin export declare function ctz(value: i32): i32;\r\n  @builtin export declare function popcnt(value: i32): i32;\r\n  @builtin export declare function rotl(value: i32, shift: i32): i32;\r\n  @builtin export declare function rotr(value: i32, shift: i32): i32;\r\n  @builtin export declare function reinterpret_f32(value: f32): i32;\r\n  @builtin export declare function load8_s(offset: usize, immOffset?: usize, immAlign?: usize): i32;\r\n  @builtin export declare function load8_u(offset: usize, immOffset?: usize, immAlign?: usize): i32;\r\n  @builtin export declare function load16_s(offset: usize, immOffset?: usize, immAlign?: usize): i32;\r\n  @builtin export declare function load16_u(offset: usize, immOffset?: usize, immAlign?: usize): i32;\r\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): i32;\r\n  @builtin export declare function store8(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\r\n  @builtin export declare function store16(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\r\n  @builtin export declare function store(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\r\n  \r\n  export namespace atomic {\r\n    @builtin export declare function load8_u(offset: usize, immOffset?: usize): i32;\r\n    @builtin export declare function load16_u(offset: usize, immOffset?: usize): i32;\r\n    @builtin export declare function load(offset: usize, immOffset?: usize): i32;\r\n    @builtin export declare function store8(offset: usize, value: i32, immOffset?: usize): void;\r\n    @builtin export declare function store16(offset: usize, value: i32, immOffset?: usize): void;\r\n    @builtin export declare function store(offset: usize, value: i32, immOffset?: usize): void;\r\n    @builtin export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\r\n\r\n    export namespace rmw8 {\r\n      @builtin export declare function add_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function sub_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function and_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function or_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function xor_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function xchg_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\r\n    }\r\n    export namespace rmw16 {\r\n      @builtin export declare function add_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function sub_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function and_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function or_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function xor_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function xchg_u(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\r\n    }\r\n    export namespace rmw {\r\n      @builtin export declare function add(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function sub(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function and(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function or(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function xor(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function xchg(offset: usize, value: i32, immOffset?: usize): i32;\r\n      @builtin export declare function cmpxchg(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\r\n    }\r\n  }\r\n}\r\n\r\n@builtin export declare function i64(value: void): i64;\r\nexport namespace i64 {\r\n  @lazy export const MIN_VALUE: i64 = -9223372036854775808;\r\n  @lazy export const MAX_VALUE: i64 =  9223372036854775807;\r\n  @builtin export declare function clz(value: i64): i64;\r\n  @builtin export declare function ctz(value: i64): i64;\r\n  @builtin export declare function load8_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\r\n  @builtin export declare function load8_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\r\n  @builtin export declare function load16_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\r\n  @builtin export declare function load16_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\r\n  @builtin export declare function load32_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\r\n  @builtin export declare function load32_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\r\n  @builtin export declare function load(offset: usize, immOffset?: usize): i64;\r\n  @builtin export declare function popcnt(value: i64): i64;\r\n  @builtin export declare function rotl(value: i64, shift: i64): i64;\r\n  @builtin export declare function rotr(value: i64, shift: i64): i64;\r\n  @builtin export declare function reinterpret_f64(value: f64): i64;\r\n  @builtin export declare function store8(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\r\n  @builtin export declare function store16(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\r\n  @builtin export declare function store32(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\r\n  @builtin export declare function store(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\r\n\r\n  export namespace atomic {\r\n    @builtin export declare function load8_u(offset: usize, immOffset?: usize): i64;\r\n    @builtin export declare function load16_u(offset: usize, immOffset?: usize): i64;\r\n    @builtin export declare function load32_u(offset: usize, immOffset?: usize): i64;\r\n    @builtin export declare function load(offset: usize, immOffset?: usize): i64;\r\n    @builtin export declare function store8(offset: usize, value: i64, immOffset?: usize): void;\r\n    @builtin export declare function store16(offset: usize, value: i64, immOffset?: usize): void;\r\n    @builtin export declare function store32(offset: usize, value: i64, immOffset?: usize): void;\r\n    @builtin export declare function store(offset: usize, value: i64, immOffset?: usize): void;\r\n    @builtin export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\r\n\r\n    export namespace rmw8 {\r\n      @builtin export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\r\n    }\r\n    export namespace rmw16 {\r\n      @builtin export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\r\n    }\r\n    export namespace rmw32 {\r\n      @builtin export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\r\n    }\r\n    export namespace rmw {\r\n      @builtin export declare function add(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function sub(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function and(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function or(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function xor(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function xchg(offset: usize, value: i64, immOffset?: usize): i64;\r\n      @builtin export declare function cmpxchg(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\r\n    }\r\n  }\r\n}\r\n\r\n@builtin export declare function isize(value: void): isize;\r\nexport namespace isize {\r\n  @lazy export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\r\n    ? -2147483648\r\n    : <isize>-9223372036854775808;\r\n  @lazy export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\r\n    ? 2147483647\r\n    : <isize>9223372036854775807;\r\n}\r\n\r\n@builtin export declare function u8(value: void): u8;\r\nexport namespace u8 {\r\n  @lazy export const MIN_VALUE: u8 = 0;\r\n  @lazy export const MAX_VALUE: u8 = 255;\r\n}\r\n\r\n@builtin export declare function u16(value: void): u16;\r\nexport namespace u16 {\r\n  @lazy export const MIN_VALUE: u16 = 0;\r\n  @lazy export const MAX_VALUE: u16 = 65535;\r\n}\r\n\r\n@builtin export declare function u32(value: void): u32;\r\nexport namespace u32 {\r\n  @lazy export const MIN_VALUE: u32 = 0;\r\n  @lazy export const MAX_VALUE: u32 = 4294967295;\r\n}\r\n\r\n@builtin export declare function u64(value: void): u64;\r\nexport namespace u64 {\r\n  @lazy export const MIN_VALUE: u64 = 0;\r\n  @lazy export const MAX_VALUE: u64 = 18446744073709551615;\r\n}\r\n\r\n@builtin export declare function usize(value: void): usize;\r\nexport namespace usize {\r\n  @lazy export const MIN_VALUE: usize = 0;\r\n  @lazy export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\r\n    ? 4294967295\r\n    : <usize>18446744073709551615;\r\n}\r\n\r\n@builtin export declare function bool(value: void): bool;\r\nexport namespace bool {\r\n  @lazy export const MIN_VALUE: bool = false;\r\n  @lazy export const MAX_VALUE: bool = true;\r\n}\r\n\r\n@builtin export declare function f32(value: void): f32;\r\nexport namespace f32 {\r\n  @lazy export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\r\n  @lazy export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\r\n  @lazy export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\r\n  @lazy export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\r\n  @lazy export const MIN_SAFE_INTEGER: f32 = -16777215;\r\n  @lazy export const MAX_SAFE_INTEGER: f32 =  16777215;\r\n  @builtin export declare function abs(value: f32): f32;\r\n  @builtin export declare function ceil(value: f32): f32;\r\n  @builtin export declare function copysign(x: f32, y: f32): f32;\r\n  @builtin export declare function floor(value: f32): f32;\r\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): f32;\r\n  @builtin export declare function max(left: f32, right: f32): f32;\r\n  @builtin export declare function min(left: f32, right: f32): f32;\r\n  @builtin export declare function nearest(value: f32): f32;\r\n  @builtin export declare function reinterpret_i32(value: i32): f32;\r\n  @builtin export declare function sqrt(value: f32): f32;\r\n  @builtin export declare function store(offset: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\r\n  @builtin export declare function trunc(value: f32): f32;\r\n}\r\n\r\n@builtin export declare function f64(value: void): f64;\r\nexport namespace f64 {\r\n  @lazy export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\r\n  @lazy export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\r\n  @lazy export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\r\n  @lazy export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\r\n  @lazy export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\r\n  @lazy export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\r\n  @builtin export declare function abs(value: f64): f64;\r\n  @builtin export declare function ceil(value: f64): f64;\r\n  @builtin export declare function copysign(x: f64, y: f64): f64;\r\n  @builtin export declare function floor(value: f64): f64;\r\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): f64;\r\n  @builtin export declare function max(left: f64, right: f64): f64;\r\n  @builtin export declare function min(left: f64, right: f64): f64;\r\n  @builtin export declare function nearest(value: f64): f64;\r\n  @builtin export declare function reinterpret_i64(value: i64): f64;\r\n  @builtin export declare function sqrt(value: f64): f64;\r\n  @builtin export declare function store(offset: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\r\n  @builtin export declare function trunc(value: f64): f64;\r\n}\r\n\r\n@builtin export declare function v128(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\r\nexport namespace v128 {\r\n  @builtin export declare function splat<T>(x: T): v128;\r\n  @builtin export declare function extract_lane<T>(x: v128, idx: u8): T;\r\n  @builtin export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\r\n  @builtin export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\r\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): v128;\r\n  @builtin export declare function store(offset: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\r\n  @builtin export declare function add<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function sub<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function mul<T>(a: v128, b: v128): v128; // except i64\r\n  @builtin export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\r\n  @builtin export declare function neg<T>(a: v128): v128;\r\n  @builtin export declare function add_saturate<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function sub_saturate<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function shl<T>(a: v128, b: i32): v128;\r\n  @builtin export declare function shr<T>(a: v128, b: i32): v128;\r\n  @builtin export declare function and(a: v128, b: v128): v128;\r\n  @builtin export declare function or(a: v128, b: v128): v128;\r\n  @builtin export declare function xor(a: v128, b: v128): v128;\r\n  @builtin export declare function not(a: v128): v128;\r\n  @builtin export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\r\n  @builtin export declare function any_true<T>(a: v128): bool;\r\n  @builtin export declare function all_true<T>(a: v128): bool;\r\n  @builtin export declare function min<T>(a: v128, b: v128): v128; // f32, f64 only\r\n  @builtin export declare function max<T>(a: v128, b: v128): v128; // f32, f64 only\r\n  @builtin export declare function abs<T>(a: v128): v128; // f32, f64 only\r\n  @builtin export declare function sqrt<T>(a: v128): v128; // f32, f64 only\r\n  @builtin export declare function eq<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function ne<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function lt<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function le<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function gt<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function ge<T>(a: v128, b: v128): v128;\r\n  @builtin export declare function convert<T>(a: v128): v128;\r\n  @builtin export declare function trunc<T>(a: v128): v128;\r\n}\r\n\r\n@builtin export declare function i8x16(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\r\nexport namespace i8x16 {\r\n  @builtin export declare function splat(x: i8): v128;\r\n  @builtin export declare function extract_lane_s(x: v128, idx: u8): i8;\r\n  @builtin export declare function extract_lane_u(x: v128, idx: u8): u8;\r\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\r\n  @builtin export declare function add(a: v128, b: v128): v128;\r\n  @builtin export declare function sub(a: v128, b: v128): v128;\r\n  @builtin export declare function mul(a: v128, b: v128): v128;\r\n  @builtin export declare function neg(a: v128): v128;\r\n  @builtin export declare function add_saturate_s(a: v128, b: v128): v128;\r\n  @builtin export declare function add_saturate_u(a: v128, b: v128): v128;\r\n  @builtin export declare function sub_saturate_s(a: v128, b: v128): v128;\r\n  @builtin export declare function sub_saturate_u(a: v128, b: v128): v128;\r\n  @builtin export declare function shl(a: v128, b: i32): v128;\r\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\r\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\r\n  @builtin export declare function any_true(a: v128): bool;\r\n  @builtin export declare function all_true(a: v128): bool;\r\n  @builtin export declare function eq(a: v128, b: v128): v128;\r\n  @builtin export declare function ne(a: v128, b: v128): v128;\r\n  @builtin export declare function lt_s(a: v128, b: v128): v128;\r\n  @builtin export declare function lt_u(a: v128, b: v128): v128;\r\n  @builtin export declare function le_s(a: v128, b: v128): v128;\r\n  @builtin export declare function le_u(a: v128, b: v128): v128;\r\n  @builtin export declare function gt_s(a: v128, b: v128): v128;\r\n  @builtin export declare function gt_u(a: v128, b: v128): v128;\r\n  @builtin export declare function ge_s(a: v128, b: v128): v128;\r\n  @builtin export declare function ge_u(a: v128, b: v128): v128;\r\n}\r\n\r\n@builtin export declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\r\nexport namespace i16x8 {\r\n  @builtin export declare function splat(x: i16): v128;\r\n  @builtin export declare function extract_lane_s(x: v128, idx: u8): i16;\r\n  @builtin export declare function extract_lane_u(x: v128, idx: u8): u16;\r\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\r\n  @builtin export declare function add(a: v128, b: v128): v128;\r\n  @builtin export declare function sub(a: v128, b: v128): v128;\r\n  @builtin export declare function mul(a: v128, b: v128): v128;\r\n  @builtin export declare function neg(a: v128): v128;\r\n  @builtin export declare function add_saturate_s(a: v128, b: v128): v128;\r\n  @builtin export declare function add_saturate_u(a: v128, b: v128): v128;\r\n  @builtin export declare function sub_saturate_s(a: v128, b: v128): v128;\r\n  @builtin export declare function sub_saturate_u(a: v128, b: v128): v128;\r\n  @builtin export declare function shl(a: v128, b: i32): v128;\r\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\r\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\r\n  @builtin export declare function any_true(a: v128): bool;\r\n  @builtin export declare function all_true(a: v128): bool;\r\n  @builtin export declare function eq(a: v128, b: v128): v128;\r\n  @builtin export declare function ne(a: v128, b: v128): v128;\r\n  @builtin export declare function lt_s(a: v128, b: v128): v128;\r\n  @builtin export declare function lt_u(a: v128, b: v128): v128;\r\n  @builtin export declare function le_s(a: v128, b: v128): v128;\r\n  @builtin export declare function le_u(a: v128, b: v128): v128;\r\n  @builtin export declare function gt_s(a: v128, b: v128): v128;\r\n  @builtin export declare function gt_u(a: v128, b: v128): v128;\r\n  @builtin export declare function ge_s(a: v128, b: v128): v128;\r\n  @builtin export declare function ge_u(a: v128, b: v128): v128;\r\n}\r\n\r\n@builtin export declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\r\nexport namespace i32x4 {\r\n  @builtin export declare function splat(x: i32): v128;\r\n  @builtin export declare function extract_lane(x: v128, idx: u8): i32;\r\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\r\n  @builtin export declare function add(a: v128, b: v128): v128;\r\n  @builtin export declare function sub(a: v128, b: v128): v128;\r\n  @builtin export declare function mul(a: v128, b: v128): v128;\r\n  @builtin export declare function neg(a: v128): v128;\r\n  @builtin export declare function shl(a: v128, b: i32): v128;\r\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\r\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\r\n  @builtin export declare function any_true(a: v128): bool;\r\n  @builtin export declare function all_true(a: v128): bool;\r\n  @builtin export declare function eq(a: v128, b: v128): v128;\r\n  @builtin export declare function ne(a: v128, b: v128): v128;\r\n  @builtin export declare function lt_s(a: v128, b: v128): v128;\r\n  @builtin export declare function lt_u(a: v128, b: v128): v128;\r\n  @builtin export declare function le_s(a: v128, b: v128): v128;\r\n  @builtin export declare function le_u(a: v128, b: v128): v128;\r\n  @builtin export declare function gt_s(a: v128, b: v128): v128;\r\n  @builtin export declare function gt_u(a: v128, b: v128): v128;\r\n  @builtin export declare function ge_s(a: v128, b: v128): v128;\r\n  @builtin export declare function ge_u(a: v128, b: v128): v128;\r\n  @builtin export declare function trunc_s_f32x4_sat(a: v128): v128;\r\n  @builtin export declare function trunc_u_f32x4_sat(a: v128): v128;\r\n}\r\n\r\n@builtin export declare function i64x2(a: i64, b: i64): v128;\r\nexport namespace i64x2 {\r\n  @builtin export declare function splat(x: i64): v128;\r\n  @builtin export declare function extract_lane(x: v128, idx: u8): i64;\r\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\r\n  @builtin export declare function add(a: v128, b: v128): v128;\r\n  @builtin export declare function sub(a: v128, b: v128): v128;\r\n  @builtin export declare function mul(a: v128, b: v128): v128;\r\n  @builtin export declare function neg(a: v128): v128;\r\n  @builtin export declare function shl(a: v128, b: i32): v128;\r\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\r\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\r\n  @builtin export declare function any_true(a: v128): bool;\r\n  @builtin export declare function all_true(a: v128): bool;\r\n  @builtin export declare function trunc_s_f64x2_sat(a: v128): v128;\r\n  @builtin export declare function trunc_u_f64x2_sat(a: v128): v128;\r\n}\r\n\r\n@builtin export declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\r\nexport namespace f32x4 {\r\n  @builtin export declare function splat(x: f32): v128;\r\n  @builtin export declare function extract_lane(x: v128, idx: u8): f32;\r\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\r\n  @builtin export declare function add(a: v128, b: v128): v128;\r\n  @builtin export declare function sub(a: v128, b: v128): v128;\r\n  @builtin export declare function mul(a: v128, b: v128): v128;\r\n  @builtin export declare function div(a: v128, b: v128): v128;\r\n  @builtin export declare function neg(a: v128): v128;\r\n  @builtin export declare function min(a: v128, b: v128): v128;\r\n  @builtin export declare function max(a: v128, b: v128): v128;\r\n  @builtin export declare function abs(a: v128): v128;\r\n  @builtin export declare function sqrt(a: v128): v128;\r\n  @builtin export declare function eq(a: v128, b: v128): v128;\r\n  @builtin export declare function ne(a: v128, b: v128): v128;\r\n  @builtin export declare function lt(a: v128, b: v128): v128;\r\n  @builtin export declare function le(a: v128, b: v128): v128;\r\n  @builtin export declare function gt(a: v128, b: v128): v128;\r\n  @builtin export declare function ge(a: v128, b: v128): v128;\r\n  @builtin export declare function convert_s_i32x4(a: v128): v128;\r\n  @builtin export declare function convert_u_i32x4(a: v128): v128;\r\n}\r\n\r\n@builtin export declare function f64x2(a: f64, b: f64): v128;\r\nexport namespace f64x2 {\r\n  @builtin export declare function splat(x: f64): v128;\r\n  @builtin export declare function extract_lane(x: v128, idx: u8): f64;\r\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\r\n  @builtin export declare function add(a: v128, b: v128): v128;\r\n  @builtin export declare function sub(a: v128, b: v128): v128;\r\n  @builtin export declare function mul(a: v128, b: v128): v128;\r\n  @builtin export declare function div(a: v128, b: v128): v128;\r\n  @builtin export declare function neg(a: v128): v128;\r\n  @builtin export declare function min(a: v128, b: v128): v128;\r\n  @builtin export declare function max(a: v128, b: v128): v128;\r\n  @builtin export declare function abs(a: v128): v128;\r\n  @builtin export declare function sqrt(a: v128): v128;\r\n  @builtin export declare function eq(a: v128, b: v128): v128;\r\n  @builtin export declare function ne(a: v128, b: v128): v128;\r\n  @builtin export declare function lt(a: v128, b: v128): v128;\r\n  @builtin export declare function le(a: v128, b: v128): v128;\r\n  @builtin export declare function gt(a: v128, b: v128): v128;\r\n  @builtin export declare function ge(a: v128, b: v128): v128;\r\n  @builtin export declare function convert_s_i64x2(a: v128): v128;\r\n  @builtin export declare function convert_u_i64x2(a: v128): v128;\r\n}\r\n\r\nexport namespace v8x16 {\r\n  @builtin export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8, l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8): v128;\r\n}\r\n\r\n@builtin export declare function start(): void;\r\n","import {\r\n  MAX_BLENGTH,\r\n  HEADER_SIZE,\r\n  allocateUnsafe,\r\n  reallocateUnsafe,\r\n  LOAD,\r\n  STORE\r\n} from \"./internal/arraybuffer\";\r\n\r\nimport {\r\n  allocateUnsafe as allocateUnsafeString,\r\n  freeUnsafe as freeUnsafeString,\r\n  copyUnsafe as copyUnsafeString\r\n} from \"./internal/string\";\r\n\r\nimport {\r\n  COMPARATOR,\r\n  SORT\r\n} from \"./internal/sort\";\r\n\r\nimport {\r\n  itoa,\r\n  dtoa,\r\n  itoa_stream,\r\n  dtoa_stream,\r\n  MAX_DOUBLE_LENGTH\r\n} from \"./internal/number\";\r\n\r\nimport {\r\n  isArray as builtin_isArray\r\n} from \"./builtins\";\r\n\r\nexport class Array<T> {\r\n  [key: number]: T; // compatibility only\r\n\r\n  /* @internal */ buffer_: ArrayBuffer;\r\n  /* @internal */ length_: i32;\r\n\r\n  @inline static isArray<U>(value: U): bool {\r\n    return builtin_isArray(value) && value !== null;\r\n  }\r\n\r\n  constructor(length: i32 = 0) {\r\n    const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\r\n    if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\r\n    var byteLength = length << alignof<T>();\r\n    var buffer = allocateUnsafe(byteLength);\r\n    this.buffer_ = buffer;\r\n    this.length_ = length;\r\n    memory.fill(\r\n      changetype<usize>(buffer) + HEADER_SIZE,\r\n      0,\r\n      <usize>byteLength\r\n    );\r\n  }\r\n\r\n  @inline\r\n  get length(): i32 {\r\n    return this.length_;\r\n  }\r\n\r\n  set length(length: i32) {\r\n    var buffer = this.buffer_;\r\n    var capacity = buffer.byteLength >>> alignof<T>();\r\n    if (<u32>length > <u32>capacity) {\r\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\r\n      if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\r\n      buffer = reallocateUnsafe(buffer, length << alignof<T>());\r\n      this.buffer_ = buffer;\r\n    }\r\n    this.length_ = length;\r\n  }\r\n\r\n  every(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      if (!callbackfn(LOAD<T>(this.buffer_, index), index, this)) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  findIndex(predicate: (element: T, index: i32, array: Array<T>) => bool): i32 {\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      if (predicate(LOAD<T>(this.buffer_, index), index, this)) return index;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): T {\r\n    var buffer = this.buffer_;\r\n    return <u32>index < <u32>(buffer.byteLength >>> alignof<T>())\r\n      ? LOAD<T>(buffer, index)\r\n      : <T>unreachable();\r\n  }\r\n\r\n  @operator(\"{}\")\r\n  private __unchecked_get(index: i32): T {\r\n    return LOAD<T>(this.buffer_, index);\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: T): void {\r\n    var buffer = this.buffer_;\r\n    var capacity = buffer.byteLength >>> alignof<T>();\r\n    if (<u32>index >= <u32>capacity) {\r\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\r\n      if (<u32>index >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\r\n      buffer = reallocateUnsafe(buffer, (index + 1) << alignof<T>());\r\n      this.buffer_ = buffer;\r\n      this.length_ = index + 1;\r\n    }\r\n    STORE<T>(buffer, index, value);\r\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\r\n  }\r\n\r\n  @operator(\"{}=\")\r\n  private __unchecked_set(index: i32, value: T): void {\r\n    STORE<T>(this.buffer_, index, value);\r\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\r\n  }\r\n\r\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\r\n    var buffer = this.buffer_;\r\n    var len    = this.length_;\r\n\r\n    start = start < 0 ? max(len + start, 0) : min(start, len);\r\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\r\n\r\n    if (sizeof<T>() == 1) {\r\n      if (start < end) {\r\n        memory.fill(\r\n          changetype<usize>(buffer) + start + HEADER_SIZE,\r\n          <u8>value,\r\n          <usize>(end - start)\r\n        );\r\n      }\r\n    } else {\r\n      for (; start < end; ++start) {\r\n        STORE<T>(buffer, start, value);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  @inline\r\n  includes(searchElement: T, fromIndex: i32 = 0): bool {\r\n    return this.indexOf(searchElement, fromIndex) >= 0;\r\n  }\r\n\r\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\r\n    var length = this.length_;\r\n    if (length == 0 || fromIndex >= length) return -1;\r\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\r\n    var buffer = this.buffer_;\r\n    while (fromIndex < length) {\r\n      if (LOAD<T>(buffer, fromIndex) == searchElement) return fromIndex;\r\n      ++fromIndex;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  lastIndexOf(searchElement: T, fromIndex: i32 = this.length_): i32 {\r\n    var length = this.length_;\r\n    if (length == 0) return -1;\r\n    if (fromIndex < 0) fromIndex = length + fromIndex; // no need to clamp\r\n    else if (fromIndex >= length) fromIndex = length - 1;\r\n    var buffer = this.buffer_;\r\n    while (fromIndex >= 0) {                           // ^\r\n      if (LOAD<T>(buffer, fromIndex) == searchElement) return fromIndex;\r\n      --fromIndex;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  push(element: T): i32 {\r\n    var length = this.length_;\r\n    var buffer = this.buffer_;\r\n    var capacity = buffer.byteLength >>> alignof<T>();\r\n    var newLength = length + 1; // safe only if length is checked\r\n    if (<u32>length >= <u32>capacity) {\r\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\r\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\r\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\r\n      this.buffer_ = buffer;\r\n    }\r\n    this.length_ = newLength;\r\n    STORE<T>(buffer, length, element);\r\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\r\n    return newLength;\r\n  }\r\n\r\n  concat(items: Array<T>): Array<T> {\r\n    var thisLen = this.length_;\r\n    var otherLen = select(0, items.length_, items === null);\r\n    var outLen = thisLen + otherLen;\r\n    var out = new Array<T>(outLen);\r\n\r\n    if (thisLen) {\r\n      memory.copy(\r\n        changetype<usize>(out.buffer_)  + HEADER_SIZE,\r\n        changetype<usize>(this.buffer_) + HEADER_SIZE,\r\n        <usize>thisLen << alignof<T>()\r\n      );\r\n    }\r\n    if (otherLen) {\r\n      memory.copy(\r\n        changetype<usize>(out.buffer_)   + HEADER_SIZE + (<usize>thisLen << alignof<T>()),\r\n        changetype<usize>(items.buffer_) + HEADER_SIZE,\r\n        <usize>otherLen << alignof<T>()\r\n      );\r\n    }\r\n    return out;\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\r\n    var buffer = this.buffer_;\r\n    var len = this.length_;\r\n\r\n        end   = min<i32>(end, len);\r\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\r\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\r\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\r\n    var count = min(last - from, len - to);\r\n\r\n    if (from < to && to < (from + count)) {\r\n      from += count - 1;\r\n      to   += count - 1;\r\n      while (count) {\r\n        STORE<T>(buffer, to, LOAD<T>(buffer, from));\r\n        --from, --to, --count;\r\n      }\r\n    } else {\r\n      memory.copy(\r\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>to << alignof<T>()),\r\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>from << alignof<T>()),\r\n        <usize>count << alignof<T>()\r\n      );\r\n    }\r\n    return this;\r\n  }\r\n\r\n  pop(): T {\r\n    var length = this.length_;\r\n    if (length < 1) throw new RangeError(\"Array is empty\");\r\n    var element = LOAD<T>(this.buffer_, --length);\r\n    this.length_ = length;\r\n    return element;\r\n  }\r\n\r\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void {\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      callbackfn(LOAD<T>(this.buffer_, index), index, this);\r\n    }\r\n  }\r\n\r\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\r\n    var length = this.length_;\r\n    var result = new Array<U>(length);\r\n    var buffer = result.buffer_;\r\n    for (let index = 0; index < min(length, this.length_); ++index) {\r\n      STORE<U>(buffer, index, callbackfn(LOAD<T>(this.buffer_, index), index, this));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\r\n    var result = new Array<T>();\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      let value = LOAD<T>(this.buffer_, index);\r\n      if (callbackfn(value, index, this)) result.push(value);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  reduce<U>(\r\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\r\n    initialValue: U\r\n  ): U {\r\n    var accum = initialValue;\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      accum = callbackfn(accum, LOAD<T>(this.buffer_, index), index, this);\r\n    }\r\n    return accum;\r\n  }\r\n\r\n  reduceRight<U>(\r\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\r\n    initialValue: U\r\n  ): U {\r\n    var accum = initialValue;\r\n    for (let index = this.length_ - 1; index >= 0; --index) {\r\n      accum = callbackfn(accum, LOAD<T>(this.buffer_, index), index, this);\r\n    }\r\n    return accum;\r\n  }\r\n\r\n  shift(): T {\r\n    var length = this.length_;\r\n    if (length < 1) throw new RangeError(\"Array is empty\");\r\n    var buffer = this.buffer_;\r\n    var element = LOAD<T>(buffer, 0);\r\n    var lastIndex = length - 1;\r\n    memory.copy(\r\n      changetype<usize>(buffer) + HEADER_SIZE,\r\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\r\n      <usize>lastIndex << alignof<T>()\r\n    );\r\n    STORE<T>(buffer, lastIndex, <T>null);\r\n    this.length_ = lastIndex;\r\n    return element;\r\n  }\r\n\r\n  some(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      if (callbackfn(LOAD<T>(this.buffer_, index), index, this)) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  unshift(element: T): i32 {\r\n    var buffer = this.buffer_;\r\n    var capacity = buffer.byteLength >>> alignof<T>();\r\n    var length = this.length_;\r\n    var newLength = length + 1; // safe only if length is checked\r\n    if (<u32>length >= <u32>capacity) {\r\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\r\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\r\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\r\n      capacity = buffer.byteLength >>> alignof<T>();\r\n      this.buffer_ = buffer;\r\n    }\r\n    memory.copy(\r\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\r\n      changetype<usize>(buffer) + HEADER_SIZE,\r\n      <usize>(capacity - 1) << alignof<T>()\r\n    );\r\n    STORE<T>(buffer, 0, element);\r\n    this.length_ = newLength;\r\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\r\n    return newLength;\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\r\n    var len = this.length_;\r\n    begin = begin < 0 ? max(begin + len, 0) : min(begin, len);\r\n    end = end < 0 ? max(end + len, 0) : min(end, len);\r\n    len = max(end - begin, 0);\r\n    var sliced = new Array<T>(len);\r\n    if (len) {\r\n      memory.copy(\r\n        changetype<usize>(sliced.buffer_) + HEADER_SIZE,\r\n        changetype<usize>(this.buffer_) + HEADER_SIZE + (<usize>begin << alignof<T>()),\r\n        <usize>len << alignof<T>()\r\n      );\r\n    }\r\n    return sliced;\r\n  }\r\n\r\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\r\n    var length  = this.length_;\r\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\r\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\r\n    var buffer  = this.buffer_;\r\n    var spliced = new Array<T>(deleteCount);\r\n    var source  = changetype<usize>(buffer) + HEADER_SIZE + (<usize>start << alignof<T>());\r\n    memory.copy(\r\n      changetype<usize>(spliced.buffer_) + HEADER_SIZE,\r\n      source,\r\n      <usize>deleteCount << alignof<T>()\r\n    );\r\n    var offset = start + deleteCount;\r\n    if (length != offset) {\r\n      memory.copy(\r\n        source,\r\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>offset << alignof<T>()),\r\n        <usize>(length - offset) << alignof<T>()\r\n      );\r\n    }\r\n    this.length_ = length - deleteCount;\r\n    return spliced;\r\n  }\r\n\r\n  reverse(): Array<T> {\r\n    var buffer = this.buffer_;\r\n    for (let front = 0, back = this.length_ - 1; front < back; ++front, --back) {\r\n      let temp = LOAD<T>(buffer, front);\r\n      STORE<T>(buffer, front, LOAD<T>(buffer, back));\r\n      STORE<T>(buffer, back, temp);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\r\n    // TODO remove this when flow will allow trackcing null\r\n    assert(comparator); // The comparison function must be a function\r\n\r\n    var length = this.length_;\r\n    if (length <= 1) return this;\r\n    var buffer = this.buffer_;\r\n    if (length == 2) {\r\n      let a = LOAD<T>(buffer, 1); // a = arr[1]\r\n      let b = LOAD<T>(buffer, 0); // b = arr[0]\r\n      if (comparator(a, b) < 0) {\r\n        STORE<T>(buffer, 1, b);   // arr[1] = b;\r\n        STORE<T>(buffer, 0, a);   // arr[0] = a;\r\n      }\r\n      return this;\r\n    }\r\n    SORT<T>(buffer, 0, length, comparator);\r\n    return this;\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    var lastIndex = this.length_ - 1;\r\n    if (lastIndex < 0) return \"\";\r\n    var result = \"\";\r\n    var value: T;\r\n    var buffer = this.buffer_;\r\n    var sepLen = separator.length;\r\n    var hasSeparator = sepLen != 0;\r\n    if (value instanceof bool) {\r\n      if (!lastIndex) return select<string>(\"true\", \"false\", LOAD<T,bool>(buffer, 0));\r\n\r\n      let valueLen = 5; // max possible length of element len(\"false\")\r\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n      let result = allocateUnsafeString(estLen);\r\n      let offset = 0;\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<T,bool>(buffer, i);\r\n        valueLen = 4 + <i32>(!value);\r\n        copyUnsafeString(result, offset, select<string>(\"true\", \"false\", value), 0, valueLen);\r\n        offset += valueLen;\r\n        if (hasSeparator) {\r\n          copyUnsafeString(result, offset, changetype<String>(separator), 0, sepLen);\r\n          offset += sepLen;\r\n        }\r\n      }\r\n      value = LOAD<T,bool>(buffer, lastIndex);\r\n      valueLen = 4 + <i32>(!value);\r\n      copyUnsafeString(result, offset, select<string>(\"true\", \"false\", value), 0, valueLen);\r\n      offset += valueLen;\r\n\r\n      let out = result;\r\n      if (estLen > offset) {\r\n        out = result.substring(0, offset);\r\n        freeUnsafeString(result);\r\n      }\r\n      return out;\r\n    } else if (isInteger<T>()) {\r\n      if (!lastIndex) return changetype<string>(itoa<T>(LOAD<T>(buffer, 0)));\r\n\r\n      const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + <i32>isSigned<T>();\r\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n      let result = allocateUnsafeString(estLen);\r\n      let offset = 0;\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<T>(buffer, i);\r\n        offset += itoa_stream<T>(changetype<usize>(result), offset, value);\r\n        if (hasSeparator) {\r\n          copyUnsafeString(result, offset, separator, 0, sepLen);\r\n          offset += sepLen;\r\n        }\r\n      }\r\n      value = LOAD<T>(buffer, lastIndex);\r\n      offset += itoa_stream<T>(changetype<usize>(result), offset, value);\r\n      let out = result;\r\n      if (estLen > offset) {\r\n        out = result.substring(0, offset);\r\n        freeUnsafeString(result);\r\n      }\r\n      return out;\r\n    } else if (isFloat<T>()) {\r\n      if (!lastIndex) return changetype<string>(dtoa(LOAD<T,f64>(buffer, 0)));\r\n\r\n      const valueLen = MAX_DOUBLE_LENGTH;\r\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n      let result = allocateUnsafeString(estLen);\r\n      let offset = 0;\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<T,f64>(buffer, i);\r\n        offset += dtoa_stream(changetype<usize>(result), offset, value);\r\n        if (hasSeparator) {\r\n          copyUnsafeString(result, offset, separator, 0, sepLen);\r\n          offset += sepLen;\r\n        }\r\n      }\r\n      value = LOAD<T,f64>(buffer, lastIndex);\r\n      offset += dtoa_stream(changetype<usize>(result), offset, value);\r\n      let out = result;\r\n      if (estLen > offset) {\r\n        out = result.substring(0, offset);\r\n        freeUnsafeString(result);\r\n      }\r\n      return out;\r\n    } else if (isString<T>()) {\r\n      if (!lastIndex) return LOAD<string>(buffer, 0);\r\n\r\n      let estLen = 0;\r\n      for (let i = 0, len = lastIndex + 1; i < len; ++i) {\r\n        estLen += LOAD<string>(buffer, i).length;\r\n      }\r\n      let offset = 0;\r\n      let result = allocateUnsafeString(estLen + sepLen * lastIndex);\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<string>(buffer, i);\r\n        if (value) {\r\n          let valueLen = value.length;                          // tslint:disable-line:no-unsafe-any\r\n          copyUnsafeString(result, offset, value, 0, valueLen); // tslint:disable-line:no-unsafe-any\r\n          offset += valueLen;                                   // tslint:disable-line:no-unsafe-any\r\n        }\r\n        if (hasSeparator) {\r\n          copyUnsafeString(result, offset, separator, 0, sepLen);\r\n          offset += sepLen;\r\n        }\r\n      }\r\n      value = LOAD<string>(buffer, lastIndex);\r\n      if (value) {\r\n        let valueLen = value.length;                          // tslint:disable-line:no-unsafe-any\r\n        copyUnsafeString(result, offset, value, 0, valueLen); // tslint:disable-line:no-unsafe-any\r\n      }\r\n      return result;\r\n    } else if (isArray<T>()) {\r\n      if (!lastIndex) {\r\n        value = LOAD<T>(buffer, 0);\r\n        return value ? value.join(separator) : \"\"; // tslint:disable-line:no-unsafe-any\r\n      }\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<T>(buffer, i);\r\n        if (value) result += value.join(separator); // tslint:disable-line:no-unsafe-any\r\n        if (hasSeparator) result += separator;\r\n      }\r\n      value = LOAD<T>(buffer, lastIndex);\r\n      if (value) result += value.join(separator); // tslint:disable-line:no-unsafe-any\r\n      return result;\r\n    } else if (isReference<T>()) { // References\r\n      if (!lastIndex) return \"[object Object]\";\r\n      const valueLen = 15; // max possible length of element len(\"[object Object]\")\r\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n      let result = allocateUnsafeString(estLen);\r\n      let offset = 0;\r\n      for (let i = 0; i < lastIndex; ++i) {\r\n        value = LOAD<T>(buffer, i);\r\n        if (value) {\r\n          copyUnsafeString(result, offset, changetype<String>(\"[object Object]\"), 0, valueLen);\r\n          offset += valueLen;\r\n        }\r\n        if (hasSeparator) {\r\n          copyUnsafeString(result, offset, changetype<String>(separator), 0, sepLen);\r\n          offset += sepLen;\r\n        }\r\n      }\r\n      if (LOAD<T>(buffer, lastIndex)) {\r\n        copyUnsafeString(result, offset, changetype<String>(\"[object Object]\"), 0, valueLen);\r\n        offset += valueLen;\r\n      }\r\n      let out = result;\r\n      if (estLen > offset) {\r\n        out = result.substring(0, offset);\r\n        freeUnsafeString(result);\r\n      }\r\n      return out;\r\n    } else {\r\n      assert(false); // Unsupported generic typename\r\n    }\r\n  }\r\n\r\n  @inline\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  private __gc(): void {\r\n    var buffer = this.buffer_;\r\n    __gc_mark(changetype<usize>(buffer)); // tslint:disable-line\r\n    if (isManaged<T>()) {\r\n      let offset: usize = 0;\r\n      let end = <usize>this.length_ << alignof<usize>();\r\n      while (offset < end) {\r\n        __gc_mark(load<usize>(changetype<usize>(buffer) + offset, HEADER_SIZE)); // tslint:disable-line\r\n        offset += sizeof<usize>();\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { CanvasInstruction } from \"../../src/shared/CanvasInstruction\";\r\n\r\nexport class Path2DElement {\r\n  instruction: CanvasInstruction = CanvasInstruction.Commit;\r\n  transformA: f64 = 1.0;\r\n  transformB: f64 = 0.0;\r\n  transformC: f64 = 0.0;\r\n  transformD: f64 = 1.0;\r\n  transformE: f64 = 0.0;\r\n  transformF: f64 = 0.0;\r\n  count: i32 = 0;\r\n  updateTransform: bool = false;\r\n  a: f64 = 0;\r\n  b: f64 = 0;\r\n  c: f64 = 0;\r\n  d: f64 = 0;\r\n  e: f64 = 0;\r\n  f: f64 = 0;\r\n  g: f64 = 0;\r\n  h: f64 = 0;\r\n}","import {\r\n  HEADER_SIZE,\r\n  MAX_LENGTH,\r\n  allocateUnsafe,\r\n  compareUnsafe,\r\n  repeatUnsafe,\r\n  copyUnsafe,\r\n  isWhiteSpaceOrLineTerminator,\r\n  CharCode,\r\n  parse\r\n} from \"./internal/string\";\r\n\r\nimport {\r\n  STORE\r\n} from \"./internal/arraybuffer\";\r\n\r\n@sealed\r\nexport class String {\r\n\r\n  readonly length: i32; // capped to [0, MAX_LENGTH]\r\n\r\n  // TODO Add and handle second argument\r\n  static fromCharCode(code: i32): String {\r\n    var out = allocateUnsafe(1);\r\n    store<u16>(\r\n      changetype<usize>(out),\r\n      <u16>code,\r\n      HEADER_SIZE\r\n    );\r\n    return out;\r\n  }\r\n\r\n  static fromCodePoint(code: i32): String {\r\n    assert(<u32>code <= 0x10FFFF);\r\n    var sur = code > 0xFFFF;\r\n    var out = allocateUnsafe(<i32>sur + 1);\r\n    if (!sur) {\r\n      store<u16>(\r\n        changetype<usize>(out),\r\n        <u16>code,\r\n        HEADER_SIZE\r\n      );\r\n    } else {\r\n      code -= 0x10000;\r\n      let hi: u32 = (code >>> 10) + 0xD800;\r\n      let lo: u32 = (code & 0x3FF) + 0xDC00;\r\n      store<u32>(\r\n        changetype<usize>(out),\r\n        (hi << 16) | lo,\r\n        HEADER_SIZE\r\n      );\r\n    }\r\n    return out;\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  charAt(pos: i32): String {\r\n    assert(this !== null);\r\n\r\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\r\n\r\n    var out = allocateUnsafe(1);\r\n    store<u16>(\r\n      changetype<usize>(out),\r\n      load<u16>(\r\n        changetype<usize>(this) + (<usize>pos << 1),\r\n        HEADER_SIZE\r\n      ),\r\n      HEADER_SIZE\r\n    );\r\n    return out;\r\n  }\r\n\r\n  charCodeAt(pos: i32): i32 {\r\n    assert(this !== null);\r\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\r\n\r\n    return load<u16>(\r\n      changetype<usize>(this) + (<usize>pos << 1),\r\n      HEADER_SIZE\r\n    );\r\n  }\r\n\r\n  codePointAt(pos: i32): i32 {\r\n    assert(this !== null);\r\n    if (<u32>pos >= <u32>this.length) return -1; // (undefined)\r\n\r\n    var first = <i32>load<u16>(\r\n      changetype<usize>(this) + (<usize>pos << 1),\r\n      HEADER_SIZE\r\n    );\r\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length) {\r\n      return first;\r\n    }\r\n    var second = <i32>load<u16>(\r\n      changetype<usize>(this) + ((<usize>pos + 1) << 1),\r\n      HEADER_SIZE\r\n    );\r\n    if (second < 0xDC00 || second > 0xDFFF) return first;\r\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\r\n  }\r\n\r\n  @operator(\"+\")\r\n  private static __concat(left: String, right: String): String {\r\n    if (!changetype<usize>(left)) left = changetype<String>(\"null\");\r\n    return left.concat(right);\r\n  }\r\n\r\n  concat(other: String): String {\r\n    assert(this !== null);\r\n    if (other === null) other = changetype<String>(\"null\");\r\n\r\n    var thisLen: isize  = this.length;\r\n    var otherLen: isize = other.length;\r\n    var outLen: usize   = thisLen + otherLen;\r\n    if (outLen == 0) return changetype<String>(\"\");\r\n    var out = allocateUnsafe(outLen);\r\n    copyUnsafe(out, 0, this, 0, thisLen);\r\n    copyUnsafe(out, thisLen, other, 0, otherLen);\r\n    return out;\r\n  }\r\n\r\n  endsWith(searchString: String, endPosition: i32 = MAX_LENGTH): bool {\r\n    assert(this !== null);\r\n    if (searchString === null) return false;\r\n    var end = min(max(endPosition, 0), this.length);\r\n    var searchLength: isize = searchString.length;\r\n    var start: isize = end - searchLength;\r\n    if (start < 0) return false;\r\n    return !compareUnsafe(this, start, searchString, 0, searchLength);\r\n  }\r\n\r\n  @operator(\"==\")\r\n  private static __eq(left: String, right: String): bool {\r\n    if (left === right) return true;\r\n    if (left === null || right === null) return false;\r\n\r\n    var leftLength = left.length;\r\n    if (leftLength != right.length) return false;\r\n\r\n    return !compareUnsafe(left, 0, right, 0, leftLength);\r\n  }\r\n\r\n  @operator.prefix(\"!\")\r\n  private static __not(str: String): bool {\r\n    return str === null || !str.length;\r\n  }\r\n\r\n  @operator(\"!=\")\r\n  private static __ne(left: String, right: String): bool {\r\n    return !this.__eq(left, right);\r\n  }\r\n\r\n  @operator(\">\")\r\n  private static __gt(left: String, right: String): bool {\r\n    if (left === right || left === null || right === null) return false;\r\n\r\n    var leftLength  = left.length;\r\n    var rightLength = right.length;\r\n\r\n    if (!leftLength)  return false;\r\n    if (!rightLength) return true;\r\n\r\n    var length = <usize>min<i32>(leftLength, rightLength);\r\n    return compareUnsafe(left, 0, right, 0, length) > 0;\r\n  }\r\n\r\n  @operator(\">=\")\r\n  private static __gte(left: String, right: String): bool {\r\n    return !this.__lt(left, right);\r\n  }\r\n\r\n  @operator(\"<\")\r\n  private static __lt(left: String, right: String): bool {\r\n    if (left === right || left === null || right === null) return false;\r\n\r\n    var leftLength  = left.length;\r\n    var rightLength = right.length;\r\n\r\n    if (!rightLength) return false;\r\n    if (!leftLength)  return true;\r\n\r\n    var length = <usize>min<i32>(leftLength, rightLength);\r\n    return compareUnsafe(left, 0, right, 0, length) < 0;\r\n  }\r\n\r\n  @operator(\"<=\")\r\n  private static __lte(left: String, right: String): bool {\r\n    return !this.__gt(left, right);\r\n  }\r\n\r\n  @inline\r\n  includes(searchString: String, position: i32 = 0): bool {\r\n    return this.indexOf(searchString, position) != -1;\r\n  }\r\n\r\n  indexOf(searchString: String, fromIndex: i32 = 0): i32 {\r\n    assert(this !== null);\r\n    if (searchString === null) searchString = changetype<String>(\"null\");\r\n\r\n    var searchLen: isize = searchString.length;\r\n    if (!searchLen) return 0;\r\n    var len: isize = this.length;\r\n    if (!len) return -1;\r\n    var start = min<isize>(max<isize>(fromIndex, 0), len);\r\n    len -= searchLen;\r\n    for (let k: isize = start; k <= len; ++k) {\r\n      if (!compareUnsafe(this, k, searchString, 0, searchLen)) return <i32>k;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  lastIndexOf(searchString: String, fromIndex: i32 = i32.MAX_VALUE): i32 {\r\n    assert(this !== null);\r\n    if (searchString === null) searchString = changetype<String>(\"null\");\r\n\r\n    var len: isize = this.length;\r\n    var searchLen: isize = searchString.length;\r\n    if (!searchLen) return len;\r\n    if (!len) return -1;\r\n    var start = min<isize>(max(fromIndex, 0), len - searchLen);\r\n    for (let k = start; k >= 0; --k) {\r\n      if (!compareUnsafe(this, k, searchString, 0, searchLen)) return <i32>k;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  startsWith(searchString: String, position: i32 = 0): bool {\r\n    assert(this !== null);\r\n    if (searchString === null) searchString = changetype<String>(\"null\");\r\n\r\n    var pos: isize = position;\r\n    var len: isize = this.length;\r\n    var start = min(max(pos, 0), len);\r\n    var searchLength: isize = searchString.length;\r\n    if (searchLength + start > len) return false;\r\n    return !compareUnsafe(this, start, searchString, 0, searchLength);\r\n  }\r\n\r\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String {\r\n    assert(this !== null);\r\n    var intStart: isize = start;\r\n    var end: isize = length;\r\n    var size: isize = this.length;\r\n    if (intStart < 0) intStart = max(size + intStart, 0);\r\n    var resultLength = min(max(end, 0), size - intStart);\r\n    if (resultLength <= 0) return changetype<String>(\"\");\r\n    var out = allocateUnsafe(resultLength);\r\n    copyUnsafe(out, 0, this, intStart, resultLength);\r\n    return out;\r\n  }\r\n\r\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\r\n    assert(this !== null);\r\n    var len = this.length;\r\n    var finalStart = min(max(start, 0), len);\r\n    var finalEnd = min(max(end, 0), len);\r\n    var from = min<i32>(finalStart, finalEnd);\r\n    var to = max<i32>(finalStart, finalEnd);\r\n    len = to - from;\r\n    if (!len) return changetype<String>(\"\");\r\n    if (!from && to == this.length) return this;\r\n    var out = allocateUnsafe(len);\r\n    copyUnsafe(out, 0, this, from, len);\r\n    return out;\r\n  }\r\n\r\n  trim(): String {\r\n    assert(this !== null);\r\n    var length: usize = this.length;\r\n\r\n    while (\r\n      length &&\r\n      isWhiteSpaceOrLineTerminator(\r\n        load<u16>(changetype<usize>(this) + (length << 1), HEADER_SIZE)\r\n      )\r\n    ) {\r\n      --length;\r\n    }\r\n    var start: usize = 0;\r\n    while (\r\n      start < length &&\r\n      isWhiteSpaceOrLineTerminator(\r\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\r\n      )\r\n    ) {\r\n      ++start, --length;\r\n    }\r\n    if (!length) return changetype<String>(\"\");\r\n    if (!start && length == this.length) return this;\r\n    var out = allocateUnsafe(length);\r\n    copyUnsafe(out, 0, this, start, length);\r\n    return out;\r\n  }\r\n\r\n  @inline\r\n  trimLeft(): String {\r\n    return this.trimStart();\r\n  }\r\n\r\n  @inline\r\n  trimRight(): String {\r\n    return this.trimEnd();\r\n  }\r\n\r\n  trimStart(): String {\r\n    assert(this !== null);\r\n    var start: isize = 0;\r\n    var len: isize = this.length;\r\n    while (\r\n      start < len &&\r\n      isWhiteSpaceOrLineTerminator(\r\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\r\n      )\r\n    ) {\r\n      ++start;\r\n    }\r\n    if (!start) return this;\r\n    var outLen = len - start;\r\n    if (!outLen) return changetype<String>(\"\");\r\n    var out = allocateUnsafe(outLen);\r\n    copyUnsafe(out, 0, this, start, outLen);\r\n    return out;\r\n  }\r\n\r\n  trimEnd(): String {\r\n    assert(this !== null);\r\n    var len: isize = this.length;\r\n    while (\r\n      len > 0 &&\r\n      isWhiteSpaceOrLineTerminator(\r\n        load<u16>(changetype<usize>(this) + (len << 1), HEADER_SIZE)\r\n      )\r\n    ) {\r\n      --len;\r\n    }\r\n    if (len <= 0) return changetype<String>(\"\");\r\n    if (<i32>len == this.length) return this;\r\n    var out = allocateUnsafe(len);\r\n    copyUnsafe(out, 0, this, 0, len);\r\n    return out;\r\n  }\r\n\r\n  padStart(targetLength: i32, padString: String = changetype<String>(\" \")): String {\r\n    assert(this !== null);\r\n    var length = this.length;\r\n    var padLen = padString.length;\r\n    if (targetLength < length || !padLen) return this;\r\n    var len = targetLength - length;\r\n    var out = allocateUnsafe(targetLength);\r\n    if (len > padLen) {\r\n      let count = (len - 1) / padLen;\r\n      let base = count * padLen;\r\n      let rest = len - base;\r\n      repeatUnsafe(out, 0, padString, count);\r\n      if (rest) copyUnsafe(out, base, padString, 0, rest);\r\n    } else {\r\n      copyUnsafe(out, 0, padString, 0, len);\r\n    }\r\n    if (length) copyUnsafe(out, len, this, 0, length);\r\n    return out;\r\n  }\r\n\r\n  padEnd(targetLength: i32, padString: String = changetype<String>(\" \")): String {\r\n    assert(this !== null);\r\n    var length = this.length;\r\n    var padLen = padString.length;\r\n    if (targetLength < length || !padLen) return this;\r\n    var len = targetLength - length;\r\n    var out = allocateUnsafe(targetLength);\r\n    if (length) copyUnsafe(out, 0, this, 0, length);\r\n    if (len > padLen) {\r\n      let count = (len - 1) / padLen;\r\n      let base = count * padLen;\r\n      let rest = len - base;\r\n      repeatUnsafe(out, length, padString, count);\r\n      if (rest) copyUnsafe(out, base + length, padString, 0, rest);\r\n    } else {\r\n      copyUnsafe(out, length, padString, 0, len);\r\n    }\r\n    return out;\r\n  }\r\n\r\n  repeat(count: i32 = 0): String {\r\n    assert(this !== null);\r\n    var length = this.length;\r\n\r\n    // Most browsers can't handle strings 1 << 28 chars or longer\r\n    if (count < 0 || length * count > (1 << 28)) {\r\n      throw new RangeError(\"Invalid count value\");\r\n    }\r\n\r\n    if (count == 0 || !length) return changetype<String>(\"\");\r\n    if (count == 1) return this;\r\n\r\n    var result = allocateUnsafe(length * count);\r\n    repeatUnsafe(result, 0, this, count);\r\n    return result;\r\n  }\r\n\r\n  slice(beginIndex: i32, endIndex: i32 = i32.MAX_VALUE): String {\r\n    var len   = this.length;\r\n    var begin = beginIndex < 0 ? max(beginIndex + len, 0) : min(beginIndex, len);\r\n    var end   = endIndex   < 0 ? max(endIndex   + len, 0) : min(endIndex,   len);\r\n    len = end - begin;\r\n    if (len <= 0) return changetype<String>(\"\");\r\n    var out = allocateUnsafe(len);\r\n    copyUnsafe(out, 0, this, begin, len);\r\n    return out;\r\n  }\r\n\r\n  split(separator: String = null, limit: i32 = i32.MAX_VALUE): String[] {\r\n    assert(this !== null);\r\n    if (!limit) return new Array<String>();\r\n    if (separator === null) return <String[]>[this];\r\n    var length: isize = this.length;\r\n    var sepLen: isize = separator.length;\r\n    if (limit < 0) limit = i32.MAX_VALUE;\r\n    if (!sepLen) {\r\n      if (!length) return new Array<String>();\r\n      // split by chars\r\n      length = min<isize>(length, <isize>limit);\r\n      let result = new Array<String>(length);\r\n      let buffer = <ArrayBuffer>result.buffer_;\r\n      for (let i: isize = 0; i < length; ++i) {\r\n        let char = allocateUnsafe(1);\r\n        store<u16>(\r\n          changetype<usize>(char),\r\n          load<u16>(\r\n            changetype<usize>(this) + (<usize>i << 1),\r\n            HEADER_SIZE\r\n          ),\r\n          HEADER_SIZE\r\n        );\r\n        STORE<String>(buffer, i, char);\r\n      }\r\n      return result;\r\n    } else if (!length) {\r\n      let result = new Array<String>(1);\r\n      unchecked(result[0] = changetype<String>(\"\"));\r\n      return result;\r\n    }\r\n    var result = new Array<String>();\r\n    var end = 0, start = 0, i = 0;\r\n    while ((end = this.indexOf(separator, start)) != -1) {\r\n      let len = end - start;\r\n      if (len > 0) {\r\n        let out = allocateUnsafe(len);\r\n        copyUnsafe(out, 0, this, start, len);\r\n        result.push(out);\r\n      } else {\r\n        result.push(changetype<String>(\"\"));\r\n      }\r\n      if (++i == limit) return result;\r\n      start = end + sepLen;\r\n    }\r\n    if (!start) {\r\n      let result = new Array<String>(1);\r\n      unchecked(result[0] = this);\r\n      return result;\r\n    }\r\n    var len = length - start;\r\n    if (len > 0) {\r\n      let out = allocateUnsafe(len);\r\n      copyUnsafe(out, 0, this, start, len);\r\n      result.push(out);\r\n    } else {\r\n      result.push(changetype<String>(\"\"));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  toString(): String {\r\n    return this;\r\n  }\r\n\r\n  get lengthUTF8(): i32 {\r\n    var len = 1; // null terminated\r\n    var pos: usize = 0;\r\n    var end = <usize>this.length;\r\n    while (pos < end) {\r\n      let c = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\r\n      if (c < 128) {\r\n        len += 1; ++pos;\r\n      } else if (c < 2048) {\r\n        len += 2; ++pos;\r\n      } else {\r\n        if (\r\n          (c & 0xFC00) == 0xD800 && pos + 1 < end &&\r\n          (<u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE) & 0xFC00) == 0xDC00\r\n        ) {\r\n          len += 4; pos += 2;\r\n        } else {\r\n          len += 3; ++pos;\r\n        }\r\n      }\r\n    }\r\n    return len;\r\n  }\r\n\r\n  static fromUTF8(ptr: usize, len: usize): String {\r\n    if (len < 1) return changetype<String>(\"\");\r\n    var ptrPos = <usize>0;\r\n    var buf = memory.allocate(<usize>len << 1);\r\n    var bufPos = <usize>0;\r\n    while (ptrPos < len) {\r\n      let cp = <u32>load<u8>(ptr + ptrPos++);\r\n      if (cp < 128) {\r\n        store<u16>(buf + bufPos, cp);\r\n        bufPos += 2;\r\n      } else if (cp > 191 && cp < 224) {\r\n        assert(ptrPos + 1 <= len);\r\n        store<u16>(buf + bufPos, (cp & 31) << 6 | load<u8>(ptr + ptrPos++) & 63);\r\n        bufPos += 2;\r\n      } else if (cp > 239 && cp < 365) {\r\n        assert(ptrPos + 3 <= len);\r\n        cp = (\r\n          (cp                       &  7) << 18 |\r\n          (load<u8>(ptr + ptrPos++) & 63) << 12 |\r\n          (load<u8>(ptr + ptrPos++) & 63) <<  6 |\r\n           load<u8>(ptr + ptrPos++) & 63\r\n        ) - 0x10000;\r\n        store<u16>(buf + bufPos, 0xD800 + (cp >> 10));\r\n        bufPos += 2;\r\n        store<u16>(buf + bufPos, 0xDC00 + (cp & 1023));\r\n        bufPos += 2;\r\n      } else {\r\n        assert(ptrPos + 2 <= len);\r\n        store<u16>(buf + bufPos,\r\n          (cp                       & 15) << 12 |\r\n          (load<u8>(ptr + ptrPos++) & 63) <<  6 |\r\n           load<u8>(ptr + ptrPos++) & 63\r\n        );\r\n        bufPos += 2;\r\n      }\r\n    }\r\n    assert(ptrPos == len);\r\n    var str = allocateUnsafe(<u32>(bufPos >> 1));\r\n    memory.copy(changetype<usize>(str) + HEADER_SIZE, buf, bufPos);\r\n    memory.free(buf);\r\n    return str;\r\n  }\r\n\r\n  toUTF8(): usize {\r\n    var buf = memory.allocate(<usize>this.lengthUTF8);\r\n    var pos: usize = 0;\r\n    var end = <usize>this.length;\r\n    var off: usize = 0;\r\n    while (pos < end) {\r\n      let c1 = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\r\n      if (c1 < 128) {\r\n        store<u8>(buf + off, c1);\r\n        ++off; ++pos;\r\n      } else if (c1 < 2048) {\r\n        let ptr = buf + off;\r\n        store<u8>(ptr, c1 >> 6 | 192);\r\n        store<u8>(ptr, c1 & 63 | 128, 1);\r\n        off += 2; ++pos;\r\n      } else {\r\n        let ptr = buf + off;\r\n        if ((c1 & 0xFC00) == 0xD800 && pos + 1 < end) {\r\n          let c2 = <u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE);\r\n          if ((c2 & 0xFC00) == 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            store<u8>(ptr, c1 >> 18      | 240);\r\n            store<u8>(ptr, c1 >> 12 & 63 | 128, 1);\r\n            store<u8>(ptr, c1 >>  6 & 63 | 128, 2);\r\n            store<u8>(ptr, c1       & 63 | 128, 3);\r\n            off += 4; pos += 2;\r\n            continue;\r\n          }\r\n        }\r\n        store<u8>(ptr, c1 >> 12     | 224);\r\n        store<u8>(ptr, c1 >> 6 & 63 | 128, 1);\r\n        store<u8>(ptr, c1      & 63 | 128, 2);\r\n        off += 3; ++pos;\r\n      }\r\n    }\r\n    store<u8>(buf + off, 0);\r\n    return buf;\r\n  }\r\n}\r\n\r\nexport type string = String;\r\n\r\nexport function parseInt(str: String, radix: i32 = 0): f64 {\r\n  return parse<f64>(str, radix);\r\n}\r\n\r\nexport function parseI32(str: String, radix: i32 = 0): i32 {\r\n  return parse<i32>(str, radix);\r\n}\r\n\r\nexport function parseI64(str: String, radix: i32 = 0): i64 {\r\n  return parse<i64>(str, radix);\r\n}\r\n\r\n// FIXME: naive implementation\r\nexport function parseFloat(str: String): f64 {\r\n  var len: i32 = str.length;\r\n  if (!len) return NaN;\r\n\r\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\r\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n\r\n  // determine sign\r\n  var sign: f64;\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) return NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) return NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = 1;\r\n  } else {\r\n    sign = 1;\r\n  }\r\n\r\n  // calculate value\r\n  var num: f64 = 0;\r\n  while (len--) {\r\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n    if (code == CharCode.DOT) {\r\n      ptr += 2;\r\n      let fac: f64 = 0.1; // precision :(\r\n      while (len--) {\r\n        code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n        if (code == CharCode.E || code == CharCode.e) {\r\n          assert(false); // TODO\r\n        }\r\n        code -= CharCode._0;\r\n        if (<u32>code > 9) break;\r\n        num += <f64>code * fac;\r\n        fac *= 0.1;\r\n        ptr += 2;\r\n      }\r\n      break;\r\n    }\r\n    code -= CharCode._0;\r\n    if (<u32>code >= 10) break;\r\n    num = (num * 10) + code;\r\n    ptr += 2;\r\n  }\r\n  return sign * num;\r\n}\r\n","// @ts-ignore\r\n@external(\"__canvas_sys\", \"loadImage\")\r\ndeclare function loadImage(img: Image, src: string): i32;\r\n\r\n// @ts-ignore\r\n@external(\"__canvas_sys\", \"disposeImage\")\r\ndeclare function disposeImage(id: i32): void;\r\n\r\nexport class Image {\r\n  private _id: i32 = -1;\r\n  private _width: i32 = 0;\r\n  private _height: i32 = 0;\r\n  private _loaded: bool = false;\r\n  private _src: string = \"\";\r\n\r\n  @inline\r\n  public get width(): number {\r\n    return this._width;\r\n  }\r\n\r\n  @inline\r\n  public get height(): number {\r\n    return this._height;\r\n  }\r\n\r\n  @inline\r\n  public get loaded(): bool {\r\n    return this._loaded;\r\n  }\r\n\r\n  @inline\r\n  public get src(): string {\r\n    return this._src;\r\n  }\r\n\r\n  public set src(value: string) {\r\n    this._src = value;\r\n    this._id = loadImage(this, value);\r\n  }\r\n\r\n  public dispose(): void {\r\n    disposeImage(this._id);\r\n  }\r\n}\r\n\r\nexport function __image_loaded(img: Image, width: i32, height: i32): void {\r\n  store<i32>(changetype<usize>(img) + offsetof<Image>(\"_width\"), width);\r\n  store<i32>(changetype<usize>(img) + offsetof<Image>(\"_height\"), height);\r\n  store<bool>(changetype<usize>(img) + offsetof<Image>(\"_loaded\"), true);\r\n}\r\n\r\n/**\r\n * Gets the image's external id.\r\n *\r\n * @param image - The target image.\r\n */\r\n// @ts-ignore: @inline is valid on regular functions\r\n@inline\r\nexport function getImageID(image: Image): i32 {\r\n  return load<i32>(changetype<usize>(image) + offsetof<Image>(\"_id\"));\r\n}\r\n","import \"allocator/arena\";\r\n\r\nimport {\r\n  CanvasDirection,\r\n  CanvasGradient,\r\n  CanvasPattern,\r\n  CanvasPatternRepetition,\r\n  CanvasRenderingContext2D,\r\n  FillRule,\r\n  GlobalCompositeOperation,\r\n  Image,\r\n  ImageSmoothingQuality,\r\n  LineCap,\r\n  LineJoin,\r\n  TextAlign,\r\n  TextBaseline,\r\n  getContextById,\r\n } from \"./index\";\r\n\r\nvar ctx: CanvasRenderingContext2D;\r\nvar grd: CanvasGradient;\r\nvar img: Image;\r\nvar ptrn: CanvasPattern;\r\n\r\nexport function arc(x: number, y: number, r: number, startAngle: number, endAngle: number, anticlockwise: bool): void {\r\n  assert(ctx);\r\n  ctx.arc(x, y, r, startAngle, endAngle, anticlockwise);\r\n}\r\n\r\nexport function init(): void {\r\n  ctx = getContextById(\"main\");\r\n}\r\n\r\nexport function fillStyle(value: string): void {\r\n  assert(ctx);\r\n  ctx.fillStyle = value;\r\n}\r\n\r\nexport function strokeStyle(value: string): void {\r\n  assert(ctx);\r\n  ctx.strokeStyle = value;\r\n}\r\n\r\nexport function fill(fillRule: FillRule = FillRule.nonzero): void {\r\n  assert(ctx);\r\n  ctx.fill(fillRule);\r\n}\r\n\r\nexport function stroke(): void {\r\n  assert(ctx);\r\n  ctx.stroke();\r\n}\r\n\r\nexport function commit(): void {\r\n  assert(ctx);\r\n  ctx.commit();\r\n}\r\n\r\nexport function filter(str: string): void {\r\n  assert(ctx);\r\n  ctx.filter = str;\r\n}\r\n\r\nexport function globalAlpha(value: f64): void {\r\n  assert(ctx);\r\n  ctx.globalAlpha = value;\r\n}\r\n\r\nexport function imageSmoothingEnabled(value: bool): void {\r\n  assert(ctx);\r\n  ctx.imageSmoothingEnabled = value;\r\n}\r\n\r\nexport function imageSmoothingQuality(value: ImageSmoothingQuality): void {\r\n  assert(ctx);\r\n  ctx.imageSmoothingQuality = value;\r\n}\r\n\r\nexport function shadowBlur(value: f64): void {\r\n  assert(ctx);\r\n  ctx.shadowBlur = value;\r\n}\r\n\r\nexport function shadowColor(value: string): void {\r\n  assert(ctx);\r\n  ctx.shadowColor = value;\r\n}\r\n\r\nexport function shadowOffsetY(value: f64): void {\r\n  assert(ctx);\r\n  ctx.shadowOffsetY = value;\r\n}\r\n\r\nexport function shadowOffsetX(value: f64): void {\r\n  assert(ctx);\r\n  ctx.shadowOffsetX = value;\r\n}\r\n\r\nexport function createRadialGradient(x0: f64, y0: f64, r0: f64, x1: f64, y1: f64, r1: f64): i32 {\r\n  assert(ctx);\r\n  grd = ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);\r\n  assert(grd);\r\n  return load<i32>(changetype<usize>(grd) + offsetof<CanvasGradient>(\"id\"));\r\n}\r\n\r\nexport function fillGradient(): void {\r\n  assert(ctx);\r\n  assert(grd);\r\n  ctx.fillGradient = grd;\r\n}\r\n\r\nexport function strokeGradient(): void {\r\n  assert(ctx);\r\n  assert(grd);\r\n  ctx.strokeGradient = grd;\r\n}\r\n\r\nexport function createImage(): i32 {\r\n  img = new Image();\r\n  assert(img);\r\n  img.src = \"http://placekitten.com/400/300\";\r\n  return load<i32>(changetype<usize>(img) + offsetof<Image>(\"_id\"));\r\n}\r\n\r\nexport function createPattern(): i32 {\r\n  assert(ctx);\r\n  assert(img);\r\n  assert(img.loaded);\r\n  ptrn = ctx.createPattern(img, CanvasPatternRepetition.repeat);\r\n  return load<i32>(changetype<usize>(ptrn) + offsetof<CanvasPattern>(\"id\"));\r\n}\r\n\r\nexport function fillPattern(): void {\r\n  assert(ctx);\r\n  assert(ptrn);\r\n  ctx.fillPattern = ptrn;\r\n}\r\n\r\nexport function strokePattern(): void {\r\n  assert(ctx);\r\n  assert(ptrn);\r\n  ctx.strokePattern = ptrn;\r\n}\r\n\r\nexport function setTransform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n  assert(ctx);\r\n  ctx.setTransform(a, b, c, d, e, f);\r\n}\r\n\r\nexport function clearRect(x: f64, y: f64, width: f64, height: f64): void {\r\n  assert(ctx);\r\n  ctx.clearRect(x, y, width, height);\r\n}\r\n\r\nexport function arcTo(x1: f64, y1: f64, x2: f64, y2: f64, radius: f64): void {\r\n  assert(ctx);\r\n  ctx.arcTo(x1, y1, x2, y2, radius);\r\n}\r\n\r\nexport function bezierCurveTo(cp1x: f64, cp1y: f64, cp2x: f64, cp2y: f64, x: f64, y: f64): void {\r\n  assert(ctx);\r\n  ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\r\n}\r\n\r\nexport function clip(): void {\r\n  assert(ctx);\r\n  ctx.clip();\r\n}\r\n\r\nexport function closePath(): void {\r\n  assert(ctx);\r\n  ctx.closePath();\r\n}\r\n\r\nexport function ellipse(x: f64, y: f64, radiusX: f64, radiusY: f64, rotation: f64, startAngle: f64, endAngle: f64, anticlockwise: bool): void {\r\n  assert(ctx);\r\n  ctx.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);\r\n}\r\n\r\nexport function lineTo(x: f64, y: f64): void {\r\n  assert(ctx);\r\n  ctx.lineTo(x, y);\r\n}\r\n\r\nexport function moveTo(x: f64, y: f64): void {\r\n  assert(ctx);\r\n  ctx.moveTo(x, y);\r\n}\r\n\r\nexport function quadraticCurveTo(cpx: f64, cpy: f64, x: f64, y: f64): void {\r\n  assert(ctx);\r\n  ctx.quadraticCurveTo(cpx, cpy, x, y);\r\n}\r\n\r\nexport function rect(x: f64, y: f64, width: f64, height: f64): void {\r\n  assert(ctx);\r\n  ctx.rect(x, y, width, height);\r\n}\r\n\r\nexport function globalCompositeOperation(operation: GlobalCompositeOperation): void {\r\n  assert(ctx);\r\n  ctx.globalCompositeOperation = operation;\r\n}\r\n\r\nexport function fillRect(x: f64, y: f64, width: f64, height: f64): void {\r\n  assert(ctx);\r\n  ctx.fillRect(x, y, width, height);\r\n}\r\n\r\nexport function drawImage(dx: f64, dy: f64): void {\r\n  assert(ctx);\r\n  ctx.drawImage(img, dx, dy);\r\n}\r\n\r\nexport function drawImageSize(dx: f64, dy: f64, dWidth: f64, dHeight: f64): void {\r\n  assert(ctx);\r\n  ctx.drawImageSize(img, dx, dy, dWidth, dHeight);\r\n}\r\n\r\nexport function drawImageSource(sx: f64, sy: f64, sWidth: f64, sHeight: f64, dx: f64, dy: f64, dWidth: f64, dHeight: f64): void {\r\n  assert(ctx);\r\n  ctx.drawImageSource(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\r\n}\r\n\r\nexport function fillText(text: string, x: f64, y: f64): void {\r\n  assert(ctx);\r\n  ctx.fillText(text, x, y);\r\n}\r\n\r\nexport function fillTextWidth(text: string, x: f64, y: f64, width: f64): void {\r\n  assert(ctx);\r\n  ctx.fillTextWidth(text, x, y, width);\r\n}\r\n\r\nexport function direction(value: CanvasDirection): void {\r\n  assert(ctx);\r\n  ctx.direction = value;\r\n}\r\n\r\nexport function font(value: string): void {\r\n  assert(ctx);\r\n  ctx.font = value;\r\n}\r\n\r\nexport function textAlign(value: TextAlign): void {\r\n  assert(ctx);\r\n  ctx.textAlign = value;\r\n}\r\n\r\nexport function textBaseline(value: TextBaseline): void {\r\n  assert(ctx);\r\n  ctx.textBaseline = value;\r\n}\r\n\r\nexport function measureText(value: string): f64 {\r\n  assert(ctx);\r\n  return ctx.measureText(value);\r\n}\r\n\r\nexport function lineCap(value: LineCap): void {\r\n  assert(ctx);\r\n  ctx.lineCap = value;\r\n}\r\n\r\nexport function setLineDash(a: f64, b: f64, c: f64): void {\r\n  assert(ctx);\r\n  var array = new Float64Array(3);\r\n  array[0] = a;\r\n  array[1] = b;\r\n  array[2] = c;\r\n  ctx.setLineDash(array);\r\n}\r\n\r\nexport function lineDashOffset(value: f64): void {\r\n  assert(ctx);\r\n  ctx.lineDashOffset = value;\r\n}\r\n\r\nexport function lineJoin(value: LineJoin): void {\r\n  assert(ctx);\r\n  ctx.lineJoin = value;\r\n}\r\n\r\nexport function lineWidth(value: f64): void {\r\n  assert(ctx);\r\n  ctx.lineWidth = value;\r\n}\r\n\r\nexport function miterLimit(value: f64): void {\r\n  assert(ctx);\r\n  ctx.miterLimit = value;\r\n}\r\n\r\nexport function strokeRect(x: f64, y: f64, width: f64, height: f64): void {\r\n  assert(ctx);\r\n  ctx.strokeRect(x, y, width, height);\r\n}\r\n\r\nexport function strokeText(text: string, x: f64, y: number): void {\r\n  assert(ctx);\r\n  ctx.strokeText(text, x, y);\r\n}\r\n\r\nexport function strokeTextWidth(text: string, x: f64, y: f64, width: f64): void {\r\n  assert(ctx);\r\n  ctx.strokeTextWidth(text, x, y, width);\r\n}\r\n\r\nexport function save(hard: bool): void {\r\n  assert(ctx);\r\n  ctx.save(hard);\r\n}\r\n\r\nexport function restore(): void {\r\n  assert(ctx);\r\n  ctx.restore();\r\n}\r\n\r\nexport function imageNull(): void {\r\n  // @ts-ignore\r\n  img = null;\r\n}\r\n\r\nexport function rotate(angle: f64): void {\r\n  assert(ctx);\r\n  ctx.rotate(angle);\r\n}\r\n\r\nexport function scale(x: f64, y: f64): void {\r\n  assert(ctx);\r\n  ctx.scale(x, y);\r\n}\r\n\r\nexport function transform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\r\n  assert(ctx);\r\n  ctx.transform(a, b, c, d, e, f);\r\n}\r\n\r\nexport function translate(x: f64, y: f64): void {\r\n  assert(ctx);\r\n  ctx.translate(x, y);\r\n}\r\n","@inline\r\nexport function arraysEqual(left: Float64Array, right: Float64Array): bool {\r\n  var len: i32 = left.length;\r\n  var valid = true;\r\n  if (len == right.length) {\r\n    for (var i = 0; i < len; i++) {\r\n      if (unchecked(left[i]) != unchecked(right[i])) {\r\n        valid = false;\r\n        break;\r\n      }\r\n    }\r\n  } else {\r\n    valid = false;\r\n  }\r\n  return valid;\r\n}\r\n\r\n@inline\r\nexport function checkDoubleArray(value: Float64Array): Float64Array {\r\n  var len: i32 = value.length;\r\n  var double: bool = <bool>(len & 1);\r\n  var result: Float64Array = new Float64Array(double ? len * 2 : len);\r\n  var doublelen: i32;\r\n  var i: i32 = 0;\r\n  for (;i < len; ++i) {\r\n    unchecked(result[i] = value[i]);\r\n  }\r\n  if (double) {\r\n    doublelen = len << 1;\r\n    for(;i < doublelen; i++) {\r\n      unchecked(result[i] = value[i - len]);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n","// @ts-ignore: decorators are valid here\r\n@external(\"__canvas_sys\", \"addColorStop\")\r\ndeclare function addColorStop(id: i32, offset: f64, color: string): void;\r\n\r\n// @ts-ignore: decorators are valid here\r\n@external(\"__canvas_sys\", \"disposeCanvasGradient\")\r\ndeclare function disposeCanvasGradient(id: i32): void;\r\n\r\n/**\r\n * The CanvasGradient interface represents an opaque object describing a gradient. It is returned\r\n * by the methods CanvasRenderingContext2D.createLinearGradient() or\r\n * CanvasRenderingContext2D.createRadialGradient().\r\n *\r\n * It can be used as a fillGradient or strokeGradient.\r\n */\r\nexport class CanvasGradient {\r\n  private id: i32 = -1;\r\n\r\n  /**\r\n   * The CanvasGradient.addColorStop() method adds a new color stop, defined by an offset and a\r\n   * color, to a given canvas gradient.\r\n   *\r\n   * @param {f64} offset - A number between 0 and 1, inclusive, representing the position of the\r\n   * color stop. 0 represents the start of the gradient and 1 represents the end; an INDEX_SIZE_ERR\r\n   * is raised if the number is outside that range. This number is clamped to the inclusive [0,1]\r\n   * range before it is passed to the browser.\r\n   * @param {string} color - A CSS <color> value representing the color of the stop. A SYNTAX_ERR is\r\n   * raised if the value cannot be parsed as a CSS <color> value.\r\n   */\r\n  public addColorStop(offset: f64, color: string): void {\r\n    addColorStop(this.id, max<f64>(min(offset, 0.0), 1.0), color);\r\n  }\r\n\r\n  /**\r\n   * This method frees the CanvasGradient from the host's gradient index.\r\n   */\r\n  public dispose(): void {\r\n    disposeCanvasGradient(this.id);\r\n  }\r\n}","// @ts-ignore\r\n@external(\"__canvas_sys\", \"disposeCanvasPattern\")\r\ndeclare function disposeCanvasPattern(id: i32): void;\r\n\r\n/**\r\n * The CanvasPattern interface represents an opaque object describing a pattern, based on an image,\r\n * a canvas, or a video, created by the CanvasRenderingContext2D.createPattern() method.\r\n */\r\nexport class CanvasPattern {\r\n  private id: i32 = -1;\r\n\r\n\r\n  /**\r\n   * This method frees the CanvasPattern from the host's pattern index.\r\n   */\r\n  public dispose(): void {\r\n    disposeCanvasPattern(this.id);\r\n  }\r\n}\r\n"]}